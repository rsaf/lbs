'use strict';
var Q = require('q');
var alipay = require('./lib/alipay');
var fs = require("fs");

//Variables
var message = null;   // message function
var platformAccountId = "F00001";
var platformCommissionAccountId = "F00002";
var platformCreditSalesAccountId = "F00003";
var alipayAccountId = "Alipay";

//DB Models
var sequelize = null;
var accountBalance = null;
var paymentOrder = null;
var transactionHistory = null;
var commissionBalance = null;

//Initiate API
function init(m) {
    console.log('Initializing API...');
    var r = {pl: null, er: ''};
    if (!(m.pl.fn instanceof Function)) {
        r.er = {ec: null, em: 'Payload pl is not a function'};
        return Q.fail(r);
    }
    message = m.pl.fn;
    // the promise for this init is completed once we get connected to postgres
    var p1 = message({
        op: 'dependency',
        pl: {dn: 'sequelize'}
    });

    return Q.all([p1]).then(function (r1) {
        sequelize = r1[0].pl.fn;

        //console.log('sequelize object ...', sequelize);

        return   __importModels(sequelize).then(function (r2) {

            return     __sync(sequelize).then(function (r3) {

                accountBalance = sequelize.models.accountBalance;
                paymentOrder = sequelize.models.paymentOrder;
                transactionHistory = sequelize.models.transactionHistory;
                //Set up table relationships
                paymentOrder.hasMany(transactionHistory, {foreignKey: 'id'});
                transactionHistory.belongsTo(paymentOrder, {foreignKey: 'paymentOrderId'});

                //create system account
                var p2 = accountBalance.findOrCreate({
                    where: {accountId: platformAccountId},
                    defaults: {accountType: "admin"}
                })
                        .spread(function (user, created) {
                            if (created) {
                                return transactionHistory.findOrCreate(
                                        {
                                            where: {sourceAccountId: platformAccountId, serviceName: "账户初始化"},
                                            defaults: {
                                                paymentOrderId: 1,
                                                destinationAccountId: platformAccountId,
                                                accountBalance:10000.0,
                                                transactionId: 'FT00001'
                                            }
                                        });
                            }
                        });

                //create system commission account
                var p3 = accountBalance.findOrCreate({
                    where: {accountId: platformCommissionAccountId},
                    defaults: {accountType: "admin"}
                })
                        .spread(function (user, created) {
                            if (created) {
                                return transactionHistory.findOrCreate(
                                        {
                                            where: {
                                                sourceAccountId: platformCommissionAccountId,
                                                serviceName: "账户初始化"
                                            },
                                            defaults: {
                                                paymentOrderId: 2,
                                                destinationAccountId: platformCommissionAccountId,
                                                accountBalance: 0.0,
                                                transactionId: "FT00002"
                                            }
                                        });
                            }
                        });

                //create system sales account
                var p4 = accountBalance.findOrCreate({
                    where: {accountId: platformCreditSalesAccountId},
                    defaults: {accountType: "admin"}
                })
                        .spread(function (user, created) {
                            if (created) {
                                return transactionHistory.findOrCreate(
                                        {
                                            where: {
                                                sourceAccountId: platformCreditSalesAccountId,
                                                serviceName: "账户初始化"
                                            },
                                            defaults: {
                                                paymentOrderId: 3,
                                                destinationAccountId: platformCreditSalesAccountId,
                                                accountBalance: 0.0,
                                                transactionId: "FT00003"
                                            }
                                        });
                            }
                        });

                return Q.all([p2, p3, p4]).then(function (rv) {
                    //console.log(rv[0]);
                    //console.log(rv[1]);
                    //console.log(rv[2]);
                    console.log(rv);

                    var r = {pl: {pm: 'fmm initialization done! '}, er: null};
                    return Q(r);

                });

            }).fail(function (err3) {
               console.log('errors 3 from init fmm', err3);
            });

        }).fail(function (err2) {
            console.log('errors 2 from init fmm', err2);
        });

    });
}

//db initialization methods

var __sync = function (paramSequelize) {
    console.log('\nSyncing models...');
    var deferred = Q.defer();
    paramSequelize.sync({force: false}).complete(function (err) {
        if (!!err) {
            deferred.reject(new Error(err));
        } else {
            deferred.resolve();
        }
    });
    return deferred.promise;
};
var __importModels = function (paramSequelize) {
    console.log('\nImporting models...');
    var deferred = Q.defer();

    var modelpath = __dirname + '/models/';
    console.log('model location', modelpath);


    fs.readdir(modelpath, function (err, files) {
        if (err) {
            deferred.reject(new Error(err));
        }
        else {
            var models = files.filter(function (file) {
                return file.substr(-3) === '.js';
            });
            //Loop through array to export models and create tables
            models.forEach(function (model) {
                if (model !== 'index.js') {

                    module.exports[model] = paramSequelize.import(modelpath + model);
                }
            });
            deferred.resolve();
        }
    });

    return deferred.promise;

};


//end of db initialization methods
/*
 * fmm_createAccount 
 * Looks for a given accountId in the accountBalance table. If id is not found, a new account
 * will be created. 
 * @param {type} m {accountId(required) accountBalance(optional), accountType(required)}
 * @returns {Q@call;defer.promise} r{accountId, accountBalance, accountType}
 */
function fmm_createAccount(m) {
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    var transactionId = '000';
    console.log(m);
    sequelize.transaction(function (t) {
        return accountBalance.findOrCreate({where: {accountId: m.pl.accountId}, defaults: m.pl}, {transaction: t})
        //return accountBalance.upsert(m.pl, {accountId: m.pl.accountId}, {transaction: t})
                .spread(function (paramData, paramCreated) {
                var account = paramData.get({plain: true});
                console.log('value that will be returned', account);
                    var p = {
                        transactionId: m.pl.accountId,
                        transactionAmount: 1000.0,
                        serviceName: '账户初始化',
                        paymentOrderId: 0,
                        contextId: 1,
                        sourceAccountId: platformAccountId,
                        destinationAccountId: m.pl.accountId,
                        accountBalance: 1000.0
                    };

                // @to be checked!!!!

                   var promise1 =    transactionHistory.upsert(p, {where: {transactionId: transactionId, sourceAccountId: m.pl.accountId}, transaction: t});
                   return Q.all([promise1]).then(function(r){
                        console.log('returning from create history ', r );
                       delete account.sequelize_caught_exception;

                        return Q(account) ;
                    });
                });
    })
    .then(function (r) {
             console.log('reply before sending ', r);
             //r.pl = m.pl;
             deferred.resolve(r);
            })
            .catch(function (error) {
                console.log(error);
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;

/*
 * fmm_getUserBalance
 * Verifies the current balance of an account by accountId. 
 * @param {type} m {accountId(required), accountType(optional)}
 * @returns {Q@call;defer.promise} r{pl:{accountId , accountBalance},er:error}
 */
function fmm_getUserBalance(m) {
    var r = {pl: null, er: null};
    var deferred = Q.defer();
    accountBalance.findAndCountAll({where: {accountId: m.pl.accountId}})
            .then(function (result) {
                console.log('COUNT:',result.count);
                if(result.count===0){
                    var message = {pl:{
                            accountId:m.pl.accountId,
                            accountType:m.pl.accountType
                    },er:'testing...'};

                    return fmm_createAccount(message).then(function(rv){
                        console.log('return from fmm_createAccount', rv);
                        deferred.resolve(rv);
                    });
                }
                else{
                r.pl = result.rows;
                deferred.resolve(r);
            }
            }).catch(function (error) {
        r.er = error;
        deferred.reject(r);
    });
    return deferred.promise;
}
;

/*
 * fmm_getTransactionHistory
 * Queries the transactionHistory table for all the transactions of a given accountId.
 * @param {type} m {accountid:xyz,  filter (optional)}
 * @returns {Q@call;defer.promise} r[] {transactionId,transactionAmount,paymentOrderId,sourceAccountId,destinationAccountId,accountBalance}
 */
function fmm_getTransactionHistory(m) {
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    transactionHistory.findAndCountAll({where: sequelize.or({sourceAccountId: m.pl.accountId}, {destinationAccountId: m.pl.accountId})})
            .then(function (result) {
                r.pl = result.rows;
                deferred.resolve(r);
            })
            .fail(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;

/*
 * fmm_recordPayment
 * Records a single payment made from a srcAccount to a dstAccount. Balance is incremented and decremented 
 * accordingly and record is made in the transactionHistory table. This is a database transaction: if
 * one query fails, entire process will rollback!
 * @param {type} m.pl: sourceAccountId , destinationAccountId , paymentOrderId , paymentAmount , transactionId , serviceName , accountType(optional)
 * @returns {Q@call;defer.promise} id of last inserted transaction history
 */
function fmm_recordPayment(m) {
    var deferred = Q.defer();
    var r = {"pl": null, "er": null};
    var message = m.pl;
    if (!message) {
        r.er = 'Payload is empty!';
        return Q.fail(r);
    }
    var contextId = 0;
    //Begin transaction
    sequelize.transaction(function (t) {
        //0.Find the current contextId for this payment
        return transactionHistory.findAll({where: {transactionId: m.pl.transactionId}, limit: 1, order: 'id DESC'}, {transaction: t})
                .then(function (rows) {
                    if (rows.length === 0) {
                        contextId = 1;
                    }
                    else {
                        var row = rows[0];
                        contextId = row['contextId'] + 1;
                    }
                    //1.Find and update source account (withdrawal)
                    return accountBalance.findOrCreate({where: {accountId: message.sourceAccountId}, defaults: {accountType: message.accountType}}, {transaction: t})
                            .spread(function (user, created) {
                                return user.decrement(['accountBalance','totalCashOut'], {by: message.paymentAmount, transaction: t});
                            });
                })
                //2.Write transaction history (withdrawal)
                .then(function (srcbalance) {
                    var data = {
                        paymentOrderId: message.paymentOrderId,
                        transactionId: message.transactionId,
                        serviceName: message.serviceName,
                        contextId: contextId,
                        sourceAccountId: message.sourceAccountId,
                        destinationAccountId: message.destinationAccountId,
                        transactionAmount: message.paymentAmount * (-1), //Negative value for withdrawal
                        accountBalance: srcbalance.accountBalance
                    };
                    return transactionHistory.findOrCreate({defaults: data, where: {serviceName: message.serviceName, paymentOrderId: message.paymentOrderId, instanceId: 1, transactionId: message.transactionId}}, {transaction: t});
                })
                //3.Find and update destination account (deposit)
                .then(function (instance) {
                    return accountBalance.findOrCreate({where: {accountId: message.destinationAccountId}, defaults: {accountType: message.accountType}}, {transaction: t})
                })
                .spread(function (user, created) {
                    return user.increment(['accountBalance','totalCashIn'], {by: message.paymentAmount, transaction: t});
                })
                //4.Write transaction history (deposit)
                .then(function (destAccount) {
                    var data = {
                        paymentOrderId: message.paymentOrderId,
                        transactionId: message.transactionId,
                        serviceName: message.serviceName,
                        contextId: contextId,
                        sourceAccountId: message.sourceAccountId,
                        destinationAccountId: message.destinationAccountId,
                        transactionAmount: message.paymentAmount,
                        accountBalance: destAccount.accountBalance
                    };
                    return transactionHistory.findOrCreate({defaults: data, where: {serviceName: message.serviceName, paymentOrderId: message.paymentOrderId, instanceId: 2, transactionId: message.transactionId}}, {transaction: t});
                });
    }).then(function (paramData) {
        //Trasaction has been commited
        r.pl = paramData.dataValues;
        deferred.resolve(r);
    }).fail(function (paramError) {
        // Transaction has been rolled back
        r.er = paramError;
        deferred.reject(r);
    });
    return deferred.promise;
}
;

/*
 * fmm_recordAliPayment
 * This function is similar to fmm_recordPayment, but is called in the specific case when 
 * a user has requested to pay with Alipay. This function will record the money from 
 * Alipay to the system. It allows us to record a transaction history without necessarily
 * having a sourceAccountId to decrement. This is necessary because Alipay has no accountId
 * in our system.
 * @param {type} m{ pl: paymentOrderId , transactionId , paymentAmount, destinationAccount}
 * @returns {Q@call;defer.promise}
 */
function fmm_recordAliPayment(m) {
    var deferred = Q.defer();
    var r = {"pl": null, "er": null};
    var message = m.pl;
    var currBalance = 0;
    var contextId = 0;
    if (!message) {
        r.er = 'Payload is empty!';
        return Q.fail(r);
    }
    //Begin transaction
    sequelize.transaction(function (t) {
        //Find out if an Alipay Payment has already been done
        return transactionHistory.count({where: {transactionId: message.transactionId, paymentOrderId: message.paymentOrderId}}, {transaction: t})
                .then(function (rows) {
                    if (rows > 0) {
                        r.pl = 'Payment has already been done!';
                        //deferred.resolve(r);
                        return Q.promise;
                    }

                    //1.Find and update destination account (deposit)
                    return accountBalance.findOrCreate({where: {accountId: platformAccountId}, defaults: {accountType: 'admin'}}, {transaction: t})
                            .spread(function (user, created) {
                                return user.increment(['accountBalance','totalCashIn'], {by: message.paymentAmount, transaction: t});
                            });
                })

                .then(function (balance) {
                    //Get the current balance after incrementing
                    currBalance = balance.accountBalance;
                    //2.Find the current contextId for this payment
                    return transactionHistory.findAll({where: {transactionId: m.pl.transactionId}, limit: 1, order: 'id DESC'}, {transaction: t});
                })
                .then(function (rows) {
                    if (rows.length === 0) {
                        contextId = 1;
                    }
                    else {
                        contextId = rows[0]['contextId'] + 1;
                    }
                    return Q.promise;
                })
                //4.Write transaction history (deposit)
                .then(function () {
                    var data = {
                        paymentOrderId: message.paymentOrderId,
                        transactionId: message.transactionId,
                        contextId: contextId,
                        serviceName: 'ALIPAY_PAYMENT',
                        sourceAccountId: alipayAccountId,
                        destinationAccountId: platformAccountId,
                        transactionAmount: message.paymentAmount,
                        accountBalance: currBalance
                    };
                    return transactionHistory.findOrCreate({defaults: data, where: {serviceName: 'ALIPAY_PAYMENT', paymentOrderId: message.paymentOrderId, transactionId: message.transactionId}}, {transaction: t});
                });
    }).then(function (paramData) {
        //Trasaction has been commited
        r.pl = paramData;
        deferred.resolve(r);
    }).fail(function (paramError) {
        // Transaction has been rolled back
        r.er = paramError;
        deferred.reject(r);
    });
    return deferred.promise;
}
;

/*
 * fmm_createOrder
 * Checks to see if an order related to a transaction already exists in the orders table.
 * If doesn't exist, create new order
 * @param {type} m {
 * transactionId(required), 
 * serviceId(required),
 * serviceName (optional)
 * serviceProviderId(required) , 
 * corporationId(required),
 * userAccountId(required),
 * platformComissionAmount (required),
 * orderStatus (required),
 * orderAmount (required),
 * paymentType (default=online)
 * affiliateId (optional) 
 * affiliateCommissionAmount (optional)
 *  }
 * @returns {Q@call;defer.promise}
 */
function fmm_createOrder(m) {
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    var data = m.pl;
    paymentOrder.findOrCreate({defaults: data, where: {transactionId: data.transactionId, serviceId: data.serviceId}})
            .spread(function (order, created) {
                r.pl = order.get({plain: true});
                deferred.resolve(r);
            })
            .catch(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;


/*
 * fmm_updateOrderStatus
 * Updates the status of a given order to 'pending', 'paid', 'consumed','split','done'
 * @param {type} m {pl:orderStatus,where:{id}}
 * @returns {Q@call;defer.promise}
 */
function fmm_updateOrderStatus(m) {
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    paymentOrder.update({orderStatus: m.pl.orderStatus}, {where: m.pl.where, returning: true})
            .then(function (result) {

                r.pl = result.dataValues;
                deferred.resolve(r);
            })
            .fail(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;

/*
 * fmm_getPaymentOrders
 * Return all payment orders according to criteria specified in the where object of the message
 * @param {type} m {pl:{where}}
 * @returns {Q@call;defer.promise}
 */
function fmm_getPaymentOrders(m) {
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    paymentOrder.findAndCountAll({where: m.pl.where})
            .then(function (result) {
                r.pl = result.rows;
                deferred.resolve(r);
            })
            .catch(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
/*
 * fmm_alipayNotification
 * Verifies a notification message sent by Alipay through it's notify_id
 * @param {type} [notify_id] , accountId , transactionAmount , transactionId
 * @returns {Q@call;defer.promise} true | false |invalid
 */
function fmm_alipayNotification(m) {
    //Response
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    var q = Q();
    //Verify the notification sent from Alipay
    alipay.verifyAlipayNotification(m)
            .then(function (notification) {
                console.log('\Notification', notification);
                //When notification is legitimate, verify the user payment
                if (!notification.pl) {
                    return Q.reject('No notification from verifyAlipayNotification');
                }
                if (notification.pl) {
                    return alipay.verifyUserPayment({pl: {out_trade_no: m.pl.transactionId}, er: null});
                }
            })
            .then(function (verification) {
                //if all passed, build message for payment
                if (!verification) {
                    return Q.reject('Payment verification was not successful!');
                }

                if (!(verification.pl.is_success && verification.pl.trade_status === 'TRADE_FINISHED')) {
                    return Q.reject('No verification from verifyUserPayment');
                }
                return paymentOrder.find({where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}});
            })
            .then(function (order) {
                var order = order.dataValues;
                var p = {pl: {
                        paymentOrderId: order.id,
                        paymentAmount: order.orderAmount,
                        transactionId: order.transactionId}, er: null};
                return fmm_recordAliPayment(p);
            })
            .then(function () {
                return paymentOrder.find({where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}});
            })
            .then(function (order) {
                var order = order.dataValues;
                //If message object is empty, stop with error.
                if (typeof order === 'undefined') {
                    r.er = "No parameters defined";
                    deferred.reject(r);
                    return deferred.promise;
                }
                var p = {pl: {
                        sourceAccountId: platformAccountId,
                        destinationAccountId: m.pl.accountId,
                        serviceName: order.serviceName,
                        paymentOrderId: order.id,
                        paymentAmount: order.orderAmount,
                        transactionId: order.transactionId}, er: null};
                //Make payment of AliPay Credits to client account
                return fmm_recordPayment(p);
            })
            .then(function () {
                //Update order to done
                return fmm_updateOrderStatus({pl: {orderStatus: 'done', where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}}, er: null});
                //return paymentOrder.update({orderStatus: 'done'}, {where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}});
            })
            .then(function () {
                //Find all activity orders to be paid  
                return paymentOrder.findAll({where: {transactionId: m.pl.transactionId, serviceType: 'ACTIVITY'}})
                        .then(function (rows) {
                            rows.forEach(function (order) {
                                var p = {pl: {
                                        sourceAccountId: m.pl.accountId,
                                        destinationAccountId: platformAccountId,
                                        serviceName: order.serviceName,
                                        paymentOrderId: order.id,
                                        paymentAmount: order.orderAmount,
                                        transactionId: order.transactionId}, er: null};
                                q = q.then(function () {
                                    return fmm_recordPayment(p);
                                }).then(function () {
                                    return fmm_updateOrderStatus({pl: {orderStatus: 'paid', where: {id: order.id}}, er: null});
                                });
                            });
                        });
            })
            .then(function (order) {
                order.transactionId;
                deferred.resolve(q);
            })
            .fail(function (error) {
                r.er = error;
                console.log('ERROR:', error);
                deferred.reject(r);
            });
    return deferred.promise;
}
;

/*
 * fmm_sellCredits
 * Transfers funds from the client's account to the system account. Creates an order and records the 
 * transaction in the transactionHistory table.
 * @param {type} m {transactionId , serviceId , accountId , orderAmount}
 * @returns {undefined}
 */
function fmm_sellCredits(m) {
    var r = {"pl": null, "er": null};
    var p = {"pl": null, "er": null};
    var deferred = Q.defer();
    p.pl = {
        transactionId: m.pl.transactionId,
        serviceId: m.pl.serviceId,
        serviceName: 'CREDIT_SALE',
        serviceProviderId: platformAccountId,
        corporationId: platformAccountId,
        //userAccountId: m.pl.accountId,
        userAccountId: m.pl.userAccountId,
        serviceType: 'CREDIT_SALE',
        orderAmount: m.pl.orderAmount
    };
    //Create order for credit sales
    fmm_getUserBalance(m)
            .then(function (balance) {
                if (parseFloat(m.pl.orderAmount) > parseFloat(balance.pl.accountBalance)) {
                    r.er = 'Insufficient funds';
                    return Q.fail(r);
                }
                return fmm_createOrder(p);
            })
            .then(function (order) {
                p.pl.paymentOrderId = order.pl.id;
                p.pl.paymentAmount = order.pl.orderAmount;
                p.pl.sourceAccountId = m.pl.accountId;
                p.pl.destinationAccountId = platformCreditSalesAccountId;
                //Record the Payment
                console.log('RECORD PAY:', p);
                return fmm_recordPayment(p);
            })
            .then(function (record) {
                r.pl = record;
                deferred.resolve(record);
            })
            .catch(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;

/*
 * fmm_confirmCreditSale
 * Decrements systeam account and updates sell credits order once money has been successfuly
 * transferred from system Alipay account to the corporation's Alipay account.  
 * @param {type} m{ pl:{orderId} }
 * @returns m{pl:{paymentOrderId,paymentOrderStatus,accountBalance},er:{error}}
 */
function fmm_confirmCreditSale(m) {
    var r = {"pl": null, "er": null};
    var p = {"pl": null, "er": null};
    var deferred = Q.defer();
    sequelize.transaction(function (t) {
        //1. Find the order
        return paymentOrder.find({where: {id: m.pl.orderId}})
                .then(function (order) {
                    p.pl = {
                        paymentOrderId: order.id,
                        transactionId: order.transactionId,
                        serviceName: 'CREDIT_PAYMENT',
                        destinationAccountId: alipayAccountId,
                        sourceAccountId: platformCreditSalesAccountId,
                        transactionAmount: order.orderAmount

                    };
                    //2. Find and decrement source account (withdrawal)
                    return accountBalance.findOrCreate({where: {accountId: platformCreditSalesAccountId}, defaults: {accountType: 'admin'}}, {transaction: t})
                            .spread(function (user, created) {
                                return user.decrement(['accountBalance','totalCashOut'], {by: order.orderAmount, transaction: t});
                            });
                })
                .then(function (balance) {
                    //3. Write transaction history
                    p.pl.accountBalance = balance.accountBalance;
                    return transactionHistory.findOrCreate({defaults: p.pl, where: {serviceName: p.pl.serviceName, paymentOrderId: p.pl.paymentOrderId, instanceId: 1, transactionId: p.pl.transactionId}}, {transaction: t});
                })
                .then(function () {
                    //4. Update order status
                    p.pl.paymentOrderStatus = 'paid';
                    return fmm_updateOrderStatus({pl: {orderStatus: 'paid', where: {id: p.pl.paymentOrderId}}});
                });
    })
            .then(function () {
                r.pl = {
                    paymentOrderId: p.pl.paymentOrderId,
                    paymentOrderStatus: p.pl.paymentOrderStatus,
                    accountBalance: p.pl.accountBalance
                };
                deferred.resolve(r);
            })
            .fail(function (error) {
                r.er = error;
                deferred.reject(r);
            });
}
;

/*
 * fmm_makeDirectPayment
 * Makes a payment to an order by using direct user credit. No Alipay process involved.
 * @param {type} m{pl:{transactionId}}
 * @returns {Q@call;defer.promise}
 */
function fmm_makeDirectPayment(m) {
    var data = m.pl;
    var paymentOrderId = null;

    var p = {pl: null, er: null};
    var q = Q();

    //Response
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    //If message object is empty, stop with error.
    if (typeof data.orders === 'undefined' || !data.orders.length) {
        r.er = "No parameters defined";
        deferred.reject(r);
        return deferred.promise;
    }
    var promises = [];
    //1. Create all orders for each service
    data.orders.forEach(function (order) {
        var p = {pl: order, er: null};
        promises.push(fmm_createOrder(p));
    });
    Q.all(promises)
            .then(function (order) {
                data.orders.forEach(function (row) {
                    //2. Check if user has funds
                    q = q.then(function () {
                        var p = {pl: {accountId: row.accountId}, er: null};
                        return fmm_getUserBalance(p);
                    })
                            //3. Record Order Payment to system account
                            .then(function (balance) {
                                if (balance.accountBalance < row.orderAmount) {
                                    r.er = 'Insufficient funds';
                                    return Q.fail(r);
                                }
                                p.pl = {
                                    sourceAccountId: row.userAccountId,
                                    destinationAccountId: platformAccountId,
                                    serviceName: row.serviceName,
                                    transactionId: row.transactionId,
                                    paymentAmount: row.orderAmount,
                                    paymentOrderId: row.id
                                };
                                return fmm_recordPayment(p);
                            })
                            //4. Update the order status to paid
                            .then(function () {
                                return fmm_updateOrderStatus({pl: {orderStatus: 'paid', where: {id: row.id}}});
                            });
                });
                return q.promise;
            })
            .then(function (update) {
                r.pl = update.pl;
                deferred.resolve(q);
            })
            .fail(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;

/* Step1:fmm_generateAlipayUrl
 * Creates orders when user clicks on make payment. On success returns new transactionId and orderAmount 
 * @param Array orders[
 *                  serviceId, (required),
 *                  serviceName, (optional)
 *                  transactionId, (required)
 *                  serviceProviderId, (required) 
 *                  orderAmount, (required) 
 *                  platformComissionAmount, (required)
 *                  corporationId, (required)
 *                  affiliateId(optional),
 *                  affiliateCommissionAmount(optional),        
 *                  ] 
 *                  out_trade_no, (required) 
 *                  subject, (required)
 *                  body [optional] , 
 *                  totalAmount (required)
 * @returns {Q@call;defer.promise} Alipay compliant redirect URL
 *        
 */
function fmm_generateAlipayUrl(m) {
    var data = m.pl;
    var paymentOrderId = null;
    data.orderStatus = 'pending';
    //Response
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    //If message object is empty, stop with error.
    if (typeof data.orders === 'undefined' || !data.orders.length) {
        r.er = "No parameters defined";
        deferred.reject(r);
        return deferred.promise;
    }
    var promises = [];
    data.orders.forEach(function (order) {
        var p = {pl: order, er: null};
        promises.push(fmm_createOrder(p));
    });
    Q.all(promises)
            .then(function (order) {
                //Get the request parameters for Alipay form
                var alimsg = {pl: {
                        out_trade_no: data.out_trade_no,
                        subject: data.subject,
                        price: data.totalAmount
                    }, er: null};
                return alipay.getAlipayUrl(alimsg);
            })

            .then(function (url) {
                r.pl = {url: url.pl, paymentOrderId: paymentOrderId};
                deferred.resolve(r);
            })
            .fail(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;

/*
 * Step2: fmm_verifyAliPayment
 * User clicks on payment confirm button. Alipay transaction is checked with Alipay. If transaction was
 * successful transaction history is created and paymentOrder is updated.
 * @param transactionId
 * return aliPay Response 
 */
function fmm_verifyAliPayment(m) {
    //Initialize Response
    var r = {"pl": null, "er": null};
    var deferred = Q.defer();
    //Set Alipay message
    var alimsg = {"pl": null, "er": null};
    alimsg.pl.out_trade_no = m.pl.transactionId;
    //Verify Payment with Alipay
    alipay.verifyUserPayment(alimsg).then(function (response) {
        r.pl = response.pl;
    }).fail(function (error) {
        r.er = error;
        deferred.reject(r);
    });
    return deferred.promise;
}
;

/*
 * Step 3: fmm_splitPayment
 * After user has consumed all the services, total transaction amount should be split between the 
 * service providers of a corporation. Loop through the paymentOrder table and make payments to all
 * the service providers belonging to a given transaction id.
 * @param transactionId
 * @return  
 */
function fmm_splitPayment(m) {
    var r = {pl: null, er: null};
    var deferred = Q.defer();
    var p = {pl: null, er: null};
    var q = Q();
    //Find all orders marked for splitting
    paymentOrder.findAll({where: {orderStatus: 'split'}, paymentType: 'online', transactionId: m.pl.transactionId})
            .then(function (rows) {
                if (rows.length === 0) {
                    r.er = 'No rows marked for split!';
                    deferred.reject(r);
                }
                rows.forEach(function (row) {
                    //Record Order Payment to corporation
                    q = q.then(function () {
                        if (row.orderAmount > 0) {
                            p.pl = {
                                sourceAccountId: platformAccountId,
                                destinationAccountId: row.corporationId,
                                serviceName: 'ORDER_PAYMENT',
                                transactionId: row.transactionId,
                                paymentAmount: row.orderAmount,
                                paymentOrderId: row.id,
                                accountType: 'corporation'
                            };
                            return fmm_recordPayment(p);
                        }
                        return q.promise;
                    })
                            //Record Platform Commissions
                            .then(function () {
                                if (row.platformCommissionAmount > 0) {
                                    p.pl = {
                                        destinationAccountId: platformAccountId,
                                        sourceAccountId: row.corporationId,
                                        serviceName: 'PLATFORM_COMMISSION',
                                        transactionId: row.transactionId,
                                        paymentAmount: row.platformCommissionAmount,
                                        paymentOrderId: row.id,
                                        accountType: 'admin'
                                    };
                                    return fmm_recordPayment(p)
                                            .then(function () {
                                                p.pl = {
                                                    sourceAccountId: platformAccountId,
                                                    destinationAccountId: platformCommissionAccountId,
                                                    serviceName: 'COMMISSION_TRANSFER',
                                                    transactionId: row.transactionId,
                                                    paymentAmount: row.platformCommissionAmount,
                                                    paymentOrderId: row.id,
                                                    accountType: 'admin'
                                                };
                                                return fmm_recordPayment(p);
                                            });
                                }
                                return q.promise;
                            })
                            //Record Agent commissions
                            .then(function () {
                                if (row.agentCommissionAmount > 0) {
                                    p.pl = {
                                        destinationAccountId: row.agentId,
                                        sourceAccountId: row.corporationId,
                                        serviceName: 'AGENT_COMMISSION',
                                        transactionId: row.transactionId,
                                        paymentAmount: row.agentCommissionAmount,
                                        paymentOrderId: row.id
                                    };
                                    return fmm_recordPayment(p);
                                }
                                return q.promise;
                            })

                            //Finally...Update account status to done!
                            .then(function () {
                                return paymentOrder.update({orderStatus: 'done'}, {where: {id: row.id}});
                            });
                });
                return q.promise;
            })
            .then(function () {
                return paymentOrder.findAll({where: {orderStatus: 'paid', paymentType: 'offline', transactionId: m.pl.transactionId}})
            })
            .then(function (rows) {
                if (rows.length === 0) {
                    r.er = 'No rows marked for split!';
                    deferred.reject(r);
                }
                rows.forEach(function (row) {
                    //Record Order Payment to corporation
                    q = q.then(function () {
                        if (row.platformCommissionAmount > 0) {
                            p.pl = {
                                destinationAccountId: platformAccountId,
                                sourceAccountId: row.corporationId,
                                serviceName: 'PLATFORM_COMMISSION',
                                transactionId: row.transactionId,
                                paymentAmount: row.platformCommissionAmount,
                                paymentOrderId: row.id
                            };
                            return fmm_recordPayment(p)
                                    .then(function () {
                                        p.pl = {
                                            sourceAccountId: platformAccountId,
                                            destinationAccountId: platformCommissionAccountId,
                                            serviceName: 'COMMISSION_TRANSFER',
                                            transactionId: row.transactionId,
                                            paymentAmount: row.platformCommissionAmount,
                                            paymentOrderId: row.id
                                        };
                                        return fmm_recordPayment(p);
                                    });
                        }
                    })
                            .then(function () {
                                if (row.agentCommissionAmount > 0) {
                                    p.pl = {
                                        destinationAccountId: row.agentId,
                                        sourceAccountId: row.corporationId,
                                        serviceName: 'AGENT_COMMISSION',
                                        transactionId: row.transactionId,
                                        paymentAmount: row.agentCommissionAmount,
                                        paymentOrderId: row.id
                                    };
                                    return fmm_recordPayment(p);
                                }
                                return q.promise;
                            })
                            //Finally...Update account status to done!
                            .then(function () {
                                return paymentOrder.update({orderStatus: 'done'}, {where: {id: row.id}});
                            });
                });
                return q.promise;
            })
            .then(function () {
                deferred.resolve(q);
            })
            .fail(function (error) {
                r.er = error;
                deferred.reject(r);
            });
    return deferred.promise;
}
;

exports.operations = [init, fmm_getPaymentOrders, fmm_sellCredits, fmm_confirmCreditSale, fmm_updateOrderStatus, fmm_splitPayment, fmm_alipayNotification, fmm_createAccount, fmm_createOrder, fmm_getUserBalance, fmm_getTransactionHistory, fmm_generateAlipayUrl, fmm_verifyAliPayment, fmm_recordPayment];
// re-export ops (for testing)
exports.operations.forEach(function (op) {
    exports[op.name] = op;
});
