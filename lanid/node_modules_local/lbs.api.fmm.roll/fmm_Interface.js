/* jshint ignore:start */
'use strict';
/* jshint ignore:end */
var q = require('q');
var Alipay = require('./lib/alipay');
var alipayclass = require('./lib/alipay/alipay.class').Alipay;
var alipay = null;
var weixinPayClass = require('./lib/weixinpay/lib/payment.js').Payment;
var weixinpay = null;
var getwxOpenID = null;



var fs = require("fs");

//Variables
var message = null;   // message function
var platformAccountId = "F00001";
var platformCommissionAccountId = "F00002";
var platformCreditSalesAccountId = "F00003";
var alipayAccountId = "Alipay";

//DB Models
var sequelize = null;
var accountBalance = null;
var paymentOrder = null;
var transactionHistory = null;
var commissionBalance = null;

//Initiate API
function init(m) {
    var r = {pl: null, er: ''};
    if (!(m.pl.fn instanceof Function)) {
        r.er = {ec: null, em: 'Payload pl is not a function'};
        return q.fail(r);
    }
    message = m.pl.fn;
    // the promise for this init is completed once we get connected to postgres
    var p0 = message({
        op: 'dependency',
        pl: {dn: 'sequelize'}
    });

    var p1 = message({
        op: 'dependency',
        pl: {dn: 'alipayconfig'}
    });

    var p2 = message({
        op: 'dependency',
        pl: {dn: 'weixinpayconfig'}
    });

    var p3 = message({
        op: 'dependency',
        pl: {dn: 'getWechatOpenID'}
    });

    return q.all([p0,p1,p2,p3]).then(function (r1) {
        sequelize = r1[0].pl.fn;
        alipay =new alipayclass(r1[1].pl.fn);
        weixinpay = new weixinPayClass(r1[2].pl.fn);
        getwxOpenID = r1[3].pl.fn;

        //var m = {pl:{"code":"03140b54055f2da36a123fa4ba2949cg"}};
        //getwxOpenID(m).then(function(r){
        //    console.log(r);
        //});
        //{ pl:
        //{ access_token: 'OezXcEiiBSKSxW0eoylIeL1SSaXHnuqRH_k2Pvpj4LEvBkqm0DGIlMbzzr1qSD4P2pqy9mzVC1M5FcvEWN8ieF5jefMe9ZTNO9EMgs2RAMbop5dlhpu7NnFydANr3dagtVklI2O2JMG2WlUBKYiBRg',
        //    expires_in: 7200,
        //    refresh_token: 'OezXcEiiBSKSxW0eoylIeL1SSaXHnuqRH_k2Pvpj4LEvBkqm0DGIlMbzzr1qSD4Paewn2xrqiSN7iSR7HF7vTY19JJvKRGBtXatMUCIbbizs3owc4Q1rLOD8oy5Pr44Douu5r8ukMgtQUX4QHgqcdw',
        //    openid: 'ohu-ujoGIuuf9QxBOpyMipjGhZWQ',
        //    scope: 'snsapi_userinfo' },
        //    er: null }

       //console.log("alipayconfig", r1[1].pl.fn);
       //console.log("wexinconfig", r1[2].pl.fn);
       //
       // //testing
       // var wexinOrder = {
       //     body: "coke",
       //     //out_trade_no: 'LZR1001' + weixinpay._generateTimeStamp(),
       //     out_trade_no: "LZR1002" + "T" + parseInt(new Date() / 1000, 10),//data.out_trade_no,
       //     total_fee: "1",
       //     spbill_create_ip: "127.0.0.1",
       //     openid: "ohu-ujoGIuuf9QxBOpyMipjGhZWQ",
       //     trade_type: "JSAPI"
       // };
       //
       // weixinpay.getBrandWCPayRequestParams(wexinOrder, function(err, payargs){
       //     console.log(payargs);
       //     console.log(err);
       // });



        return   __importModels(sequelize).then(function (r2) {

            return     __sync(sequelize).then(function (r3) {

                accountBalance = sequelize.models.accountBalance;
                paymentOrder = sequelize.models.paymentOrder;
                transactionHistory = sequelize.models.transactionHistory;
                //Set up table relationships
                paymentOrder.hasMany(transactionHistory, {foreignKey: 'id'});
                transactionHistory.belongsTo(paymentOrder, {foreignKey: 'paymentOrderId'});

                //create system account
                var p2 = accountBalance.findOrCreate({
                    where: {accountId: platformAccountId},
                    defaults: {accountType: "admin"}
                })
                    .spread(function (user, created) {
                        if (created) {
                            return transactionHistory.findOrCreate(
                                {
                                    where: {sourceAccountId: platformAccountId, serviceName: "ACCOUNT_INITIATION"},
                                    defaults: {
                                        paymentOrderId: 0,
                                        destinationAccountId: platformAccountId,
                                        accountBalance: 0.0,
                                        transactionId: 'FT00001'
                                    }
                                });
                        }
                    });

                //create system commission account
                var p3 = accountBalance.findOrCreate({
                    where: {accountId: platformCommissionAccountId},
                    defaults: {accountType: "admin"}
                }).spread(function (user, created) {
                        if (created) {
                            return transactionHistory.findOrCreate(
                                {
                                    where: {
                                        sourceAccountId: platformCommissionAccountId,
                                        serviceName: "ACCOUNT_INITIATION"
                                    },
                                    defaults: {
                                        paymentOrderId: 0,
                                        destinationAccountId: platformCommissionAccountId,
                                        accountBalance: 0.0,
                                        transactionId: "FT00002"
                                    }
                                });
                        }
                    });

                //create system sales account
                var p4 = accountBalance.findOrCreate({
                    where: {accountId: platformCreditSalesAccountId},
                    defaults: {accountType: "admin"}
                })
                    .spread(function (user, created) {
                        if (created) {
                            return transactionHistory.findOrCreate(
                                {
                                    where: {
                                        sourceAccountId: platformCreditSalesAccountId,
                                        serviceName: "ACCOUNT_INITIATION"
                                    },
                                    defaults: {
                                        paymentOrderId: 0,
                                        destinationAccountId: platformCreditSalesAccountId,
                                        accountBalance: 0.0,
                                        transactionId: "FT00003"
                                    }
                                });
                        }
                    });

                return q.all([p2, p3, p4]).then(function (rv) {

                    var r = {pl: {pm: 'fmm initialization done! '}, er: null};
                    return q(r);

                });

            }).fail(function (err3) {
                console.log('errors 3 from init fmm', err3);
            });

        }).fail(function (err2) {
            console.log('errors 2 from init fmm', err2);
        });

    });
}

//db initialization methods

var __sync = function (paramSequelize) {
    console.log('\nSyncing models...');
    var deferred = q.defer();
    paramSequelize.sync({force: false}).complete(function (err) {
        if (!!err) {
            deferred.reject(new Error(err));
        } else {
            deferred.resolve();
        }
    });
    return deferred.promise;
};
var __importModels = function (paramSequelize) {
    //console.log('\nImporting models...');
    var deferred = q.defer();

    var modelpath = __dirname + '/models/';
   // console.log('model location', modelpath);


    fs.readdir(modelpath, function (err, files) {
        if (err) {
            deferred.reject(new Error(err));
        }
        else {
            var models = files.filter(function (file) {
                return file.substr(-3) === '.js';
            });
            //Loop through array to export models and create tables
            models.forEach(function (model) {
                if (model !== 'index.js') {

                    module.exports[model] = paramSequelize.import(modelpath + model);
                }
            });
            deferred.resolve();
        }
    });

    return deferred.promise;

};


//end of db initialization methods
/*
 * fmm_createAccount
 * Looks for a given accountId in the accountBalance table. If id is not found, a new account
 * will be created.
 * @param {type} m {accountId(required) accountBalance(optional), accountType(required)}
 * @returns {q@call;defer.promise} r{accountId, accountBalance, accountType}
 */
function fmm_createAccount(m) {
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    var transactionId = '000';
    sequelize.transaction(function (t) {
        return accountBalance.findOrCreate({where: {accountId: m.pl.accountId}, defaults: m.pl}, {transaction: t})
            //return accountBalance.upsert(m.pl, {accountId: m.pl.accountId}, {transaction: t})
            .spread(function (paramData, paramCreated) {
                var account = paramData.get({plain: true});
                console.log('value that will be returned', account);
                var p = {
                    transactionId: m.pl.accountId,
                    transactionAmount: 0.0,
                    serviceName: 'ACCOUNT_INITIATION',
                    paymentOrderId: 0,
                    contextId: 1,
                    sourceAccountId: platformAccountId,
                    destinationAccountId: m.pl.accountId,
                    accountBalance: 0.0
                };

                // @to be checked!!!!

                var promise1 =    transactionHistory.upsert(p, {where: {transactionId: transactionId, sourceAccountId: m.pl.accountId}, transaction: t});
                return q.all([promise1]).then(function(r){
                    console.log('returning from create history ', r );
                    delete account.sequelize_caught_exception;

                    return q(account) ;
                });
            });
    })
        .then(function (r) {
            console.log('reply before sending ', r);
            //r.pl = m.pl;
            deferred.resolve(r);
        })
        .catch(function (error) {
            console.log(error);
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}


/*
 * fmm_getUserBalance
 * Verifies the current balance of an account by accountId.
 * @param {type} m {accountId(required), accountType(optional)}
 * @returns {q@call;defer.promise} r{pl:{accountId , accountBalance},er:error}
 */
function fmm_getUserBalance(m) {
    var r = {pl: null, er: null};
    var deferred = q.defer();
    accountBalance.findAndCountAll({where: {accountId: m.pl.accountId}})
        .then(function (result) {
            if(result.count===0){
                var message = {pl:{
                    accountId:m.pl.accountId,
                    accountType:m.pl.accountType
                },er:'testing...'};

                return fmm_createAccount(message).then(function(rv){
                    console.log('return from fmm_createAccount', rv);
                    deferred.resolve(rv);
                });
            }
            else{
                r.pl = result.rows;
                deferred.resolve(r);
            }
        }).catch(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}


/*
 * fmm_getTransactionHistory
 * queries the transactionHistory table for all the transactions of a given accountId.
 * @param {type} m {accountid:xyz,  filter (optional)}
 * @returns {q@call;defer.promise} r[] {transactionId,transactionAmount,paymentOrderId,sourceAccountId,destinationAccountId,accountBalance}
 */
function fmm_getTransactionHistory(m) {
    var mt = m.mt || {}
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    var startDate = mt.sd !== undefined ? new Date(Date.parse(mt.sd)): undefined
    var endDate = mt.ed !== undefined ? new Date(Date.parse(mt.ed)) : undefined
    var filterClause = sequelize.and(
        mt.sk ?
        sequelize.or(
            {transactionId: mt.sk},
            {serviceName: mt.sk},
            {destinationAccountId:mt.sk}
        ) : undefined,
        startDate ? {createdAt : {gt : startDate}} : undefined,
        endDate ? {createdAt : {lt : endDate}} : undefined
    );
    var whereClause = sequelize.or(
            sequelize.and(
                {sourceAccountId: m.pl.accountId},
                {instanceId: 1}),
            sequelize.and(
                {destinationAccountId: m.pl.accountId},
                {instanceId:2})
        );
    if(m.pl.accountId == "admin")
    {
        whereClause = sequelize.and(
            {
                serviceName: {
                    ne: 'ACCOUNT_INITIATION'
                }
            },
            sequelize.or(
                sequelize.and({contextId:2},{instanceId:1}),
                sequelize.and({contextId:1},{instanceId:2}),
                sequelize.and({contextId:1},sequelize.or({sourceAccountId:'Alipay'},{sourceAccountId:'F00001'})),
                sequelize.and({contextId:3},{instanceId:2})
            )
        );
    }
    if(mt.sk !== undefined || mt.sd !== undefined || mt.ed !== undefined)
        whereClause = {where: sequelize.and(filterClause,whereClause)};
    else
        whereClause = {where: whereClause};
    whereClause.limit = parseInt(mt.ps) || undefined
    var offset = parseInt(mt.ps) * parseInt(mt.p);
    whereClause.offset = offset >= 0 ? offset : undefined;
    transactionHistory.findAndCountAll(whereClause)
        .then(function (result) {
            r.mt = mt;
            r.mt.tc = result.count;
            r.pl = result.rows;
            deferred.resolve(r);
        })
        .fail(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}


/*
 * fmm_recordPayment
 * Records a single payment made from a srcAccount to a dstAccount. Balance is incremented and decremented
 * accordingly and record is made in the transactionHistory table. This is a database transaction: if
 * one query fails, entire process will rollback!
 * @param {type} m.pl: sourceAccountId , destinationAccountId , paymentOrderId , paymentAmount , transactionId , serviceName , accountType(optional)
 * @returns {q@call;defer.promise} id of last inserted transaction history
 */
function fmm_recordPayment(m) {
    var deferred = q.defer();
    var r = {"pl": null, "er": null};
    var message = m.pl;
    if (!message) {
        r.er = 'Payload is empty!';
        return q.fail(r);
    }
    var contextId = 0;
    //Begin transaction
    sequelize.transaction(function (t) {
        //0.Find the current contextId for this payment
        return transactionHistory.findAll({where: {transactionId: m.pl.transactionId}, limit: 1, order: 'id DESC'}, {transaction: t})
            .then(function (rows) {
                if (rows.length === 0) {
                    contextId = 1;
                }
                else {
                    var row = rows[0];
                    contextId = row['contextId'] + 1;
                }
                //1.Find and update source account (withdrawal)
                return accountBalance.findOrCreate({where: {accountId: message.sourceAccountId}, defaults: {accountType: message.accountType}}, {transaction: t})
                    .spread(function (user, created) {
                        return user.decrement(['accountBalance','totalCashOut'], {by: message.paymentAmount, transaction: t});
                    });
            })
            //2.Write transaction history (withdrawal)
            .then(function (srcbalance) {
                var data = {
                    paymentOrderId: message.paymentOrderId,
                    transactionId: message.transactionId,
                    serviceName: message.serviceName,
                    contextId: contextId,
                    sourceAccountId: message.sourceAccountId,
                    destinationAccountId: message.destinationAccountId,
                    transactionAmount: message.paymentAmount * (-1), //Negative value for withdrawal
                    accountBalance: srcbalance.accountBalance
                };
                return transactionHistory.findOrCreate({defaults: data, where: {serviceName: message.serviceName, paymentOrderId: message.paymentOrderId, instanceId: 1, transactionId: message.transactionId}}, {transaction: t});
            })
            //3.Find and update destination account (deposit)
            .then(function (instance) {
                return accountBalance.findOrCreate({where: {accountId: message.destinationAccountId}, defaults: {accountType: message.accountType}}, {transaction: t});
            })
            .spread(function (user, created) {
                return user.increment(['accountBalance','totalCashIn'], {by: message.paymentAmount, transaction: t});
            })
            //4.Write transaction history (deposit)
            .then(function (destAccount) {
                var data = {
                    paymentOrderId: message.paymentOrderId,
                    transactionId: message.transactionId,
                    serviceName: message.serviceName,
                    contextId: contextId,
                    sourceAccountId: message.sourceAccountId,
                    destinationAccountId: message.destinationAccountId,
                    transactionAmount: message.paymentAmount,
                    accountBalance: destAccount.accountBalance
                };
                return transactionHistory.findOrCreate({defaults: data, where: {serviceName: message.serviceName, paymentOrderId: message.paymentOrderId, instanceId: 2, transactionId: message.transactionId}}, {transaction: t});
            });
    }).then(function (paramData) {
        //Trasaction has been commited
        r.pl = paramData.dataValues;
        deferred.resolve(r);
    }).fail(function (paramError) {
        // Transaction has been rolled back
        r.er = paramError;
        deferred.reject(r);
    });
    return deferred.promise;
}


/*
 * fmm_recordAliPayment
 * This function is similar to fmm_recordPayment, but is called in the specific case when
 * a user has requested to pay with Alipay. This function will record the money from
 * Alipay to the system. It allows us to record a transaction history without necessarily
 * having a sourceAccountId to decrement. This is necessary because Alipay has no accountId
 * in our system.
 * @param {type} m{ pl: paymentOrderId , transactionId , paymentAmount, destinationAccount}
 * @returns {q@call;defer.promise}
 */
function fmm_recordAliPayment(m) {
    var deferred = q.defer();
    var r = {"pl": null, "er": null};
    var message = m.pl;
    var currBalance = 0;
    var contextId = 0;
    if (!message) {
        r.er = 'Payload is empty!';
        return q.fail(r);
    }
    //Begin transaction
    sequelize.transaction(function (t) {
        //Find out if an Alipay Payment has already been done
        return transactionHistory.count({where: {transactionId: message.transactionId, paymentOrderId: message.paymentOrderId}}, {transaction: t})
            .then(function (rows) {
                if (rows > 0) {
                    r.pl = 'Payment has already been done!';
                    //deferred.resolve(r);
                    return q.promise;
                }

                //1.Find and update destination account (deposit)
                return accountBalance.findOrCreate({where: {accountId: platformAccountId}, defaults: {accountType: 'admin'}}, {transaction: t})
                    .spread(function (user, created) {
                        return user.increment(['accountBalance','totalCashIn'], {by: message.paymentAmount, transaction: t});
                    });
            })

            .then(function (balance) {
                //Get the current balance after incrementing
                currBalance = balance.accountBalance;
                //2.Find the current contextId for this payment
                return transactionHistory.findAll({where: {transactionId: m.pl.transactionId}, limit: 1, order: 'id DESC'}, {transaction: t});
            })
            .then(function (rows) {
                if (rows.length === 0) {
                    contextId = 1;
                }
                else {
                    contextId = rows[0]['contextId'] + 1;
                }
                return q.promise;
            })
            //4.Write transaction history (deposit)
            .then(function () {
                var data = {
                    paymentOrderId: message.paymentOrderId,
                    transactionId: message.transactionId,
                    contextId: contextId,
                    serviceName: 'ALIPAY',
                    sourceAccountId: alipayAccountId,
                    destinationAccountId: platformAccountId,
                    transactionAmount: message.paymentAmount,
                    accountBalance: currBalance
                };
                return transactionHistory.findOrCreate({defaults: data, where: {serviceName: 'ALIPAY', paymentOrderId: message.paymentOrderId, transactionId: message.transactionId}}, {transaction: t});
            });
    }).then(function (paramData) {
        //Trasaction has been commited
        r.pl = paramData;
        deferred.resolve(r);
    }).fail(function (paramError) {
        // Transaction has been rolled back
        r.er = paramError;
        deferred.reject(r);
    });
    return deferred.promise;
}


/*
 * fmm_createOrder
 * Checks to see if an order related to a transaction already exists in the orders table.
 * If doesn't exist, create new order
 * @param {type} m {
 * transactionId(required),
 * [serviceId(required),
 * serviceName (optional)
 * serviceProviderId(required) ,
 * corporationId(required),
 * userAccountId(required),
 * platformComissionAmount (required),
 * orderStatus (required),
 * orderAmount (required),
 * paymentType (default=online)
 * affiliateId (optional)
 * affiliateCommissionAmount (optional)
 *  }
 * @returns {q@call;defer.promise}
 */
function fmm_createOrder(m) {
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    var data = m.pl;
    console.log("CREATING ORDER, TID IS:",data.transactionId,"and SID IS:",data.serviceId);
    paymentOrder.findOrCreate({defaults: data, where: {serviceType: data.serviceType, transactionId: data.transactionId, serviceId: data.serviceId}})
        .spread(function (order, created) {
            r.pl = order.get({plain: true});
            r.pl.isNew = created;
            deferred.resolve(r);
        })
        .catch(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}



/*
 * fmm_updateOrderStatus
 * Updates the status of a given order to 'pending', 'paid', 'consumed','split','done'
 * @param {type} m {pl:orderStatus,where:{id}}
 * @returns {q@call;defer.promise}
 */
function fmm_updateOrderStatus(m) {
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    paymentOrder.update({orderStatus: m.pl.orderStatus}, {where: m.pl.where, returning: true})
        .then(function (result) {

            r.pl = result.dataValues;
            deferred.resolve(r);
        })
        .fail(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}


/*
 * fmm_getPaymentOrders
 * Return all payment orders according to criteria specified in the where object of the message
 * @param {type} m {pl:{where}}
 * @returns {q@call;defer.promise}
 */
function fmm_getPaymentOrders(m) {
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    paymentOrder.findAndCountAll({where: m.pl.where})
        .then(function (result) {
            r.pl = result.rows;
            deferred.resolve(r);
        })
        .catch(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}
/*
 * fmm_alipayNotification
 * Verifies a notification message sent by Alipay through it's notify_id
 * @param {type} [notify_id] , accountId , transactionAmount , transactionId
 * @returns {q@call;defer.promise} true | false |invalid
 */
function fmm_alipayNotification(m) {
    //Response
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    //Verify the notification sent from Alipay
    //TODO <assume verified>
    q()
    //alipay.verifyAlipayNotification(m)
    //TODO </assume verified>
        .then(function (notification) {
            //TODO <always confirmed for now>
            console.log("auto notifying");
            return {pl:true}
            //TODO </always confirmed for now>
            //When notification is legitimate, verify the user payment
            if (!notification.pl) {
                return q.reject('No notification from verifyAlipayNotification');
            }
            if (notification.pl) {
                return alipay.verifyUserPayment({pl: {out_trade_no: m.pl.transactionId}, er: null});
            }
        })
        .then(function (verification) {
            //TODO <always confirmed for now>
            console.log("auto verifying");
            verification = {pl:{is_success:true,trade_status:'TRADE_FINISHED'}}
            //TODO </always confirmed for now>
            //if all passed, build message for payment
            if (!verification) {
                return q.reject('Payment verification was not successful!');
            }

            if (!(verification.pl.is_success && verification.pl.trade_status === 'TRADE_FINISHED')) {
                return q.reject('No verification from verifyUserPayment');
            }
            return paymentOrder.find({where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}});
        })
        .then(function (o) {
            var order = o.dataValues;
            var p = {pl: {
                paymentOrderId: order.id,
                paymentAmount: order.orderAmount,
                transactionId: order.transactionId}, er: null};
            return fmm_recordAliPayment(p);
        })
        .then(function () {
            return paymentOrder.find({where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}});
        })
        .then(function (o) {
            var order = o.dataValues;
            //If message object is empty, stop with error.
            if (typeof order === 'undefined') {
                r.er = "No parameters defined";
                deferred.reject(r);
                return deferred.promise;
            }
            var p = {pl: {
                sourceAccountId: platformAccountId,
                destinationAccountId: m.pl.accountId,
                serviceName: order.serviceName,
                paymentOrderId: order.id,
                paymentAmount: order.orderAmount,
                transactionId: order.transactionId}, er: null};
            //Make payment of AliPay Credits to client account
            return fmm_recordPayment(p);
        })
        .then(function () {
            //Update order to done
            return fmm_updateOrderStatus({pl: {orderStatus: 'done', where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}}, er: null});
            //return paymentOrder.update({orderStatus: 'done'}, {where: {transactionId: m.pl.transactionId, serviceType: 'CREDIT_PURCHASE'}});
        })
        .then(function () {
            //Find all activity orders to be paid
            return paymentOrder.findAll({where: {transactionId: m.pl.transactionId, serviceType: 'ACTIVITY'}})
                .then(function (rows) {
                    return q.all(rows.map(function (order) {
                        var p = {pl: {
                            sourceAccountId: m.pl.accountId,
                            destinationAccountId: platformAccountId,
                            serviceName: order.serviceName,
                            paymentOrderId: order.id,
                            paymentAmount: order.orderAmount,
                            transactionId: order.transactionId}, er: null};
                        return fmm_recordPayment(p).then(
                            function(){
                                return fmm_updateOrderStatus({pl: {orderStatus: 'paid', where: {id: order.id}}, er: null});
                            });
                    }));
                });
        })
        .then(function (order) {
            deferred.resolve(q);
        })
        .fail(function (error) {
            r.er = error;
            console.log('ERROR:', error);
            deferred.reject(r);
        });
    return deferred.promise;
}


/*
 * fmm_sellCredits
 * Transfers funds from the client's account to the system account. Creates an order and records the
 * transaction in the transactionHistory table.
 * @param {type} m {transactionId , serviceId , accountId , orderAmount}
 * @returns {undefined}
 */
function fmm_sellCredits(m) {
    var r = {"pl": null, "er": null};
    var p = {"pl": null, "er": null};
    var deferred = q.defer();
    p.pl = {
        transactionId: m.pl.transactionId,
        serviceId: m.pl.serviceId,
        serviceName: 'CREDIT_SALE',
        serviceProviderId: platformAccountId,
        corporationId: platformAccountId,
        userAccountId: m.pl.accountId,
        serviceType: 'CREDIT_SALE',
        orderAmount: m.pl.orderAmount
    };
    //Create order for credit sales
    fmm_getUserBalance(m)
        .then(function (balance) {
            if (parseFloat(m.pl.orderAmount) > parseFloat(balance.pl.accountBalance)) {
                r.er = 'Insufficient funds';
                return q.fail(r);
            }
            return fmm_createOrder(p);
        })
        .then(function (order) {
            p.pl.paymentOrderId = order.pl.id;
            p.pl.paymentAmount = order.pl.orderAmount;
            p.pl.sourceAccountId = m.pl.accountId;
            p.pl.destinationAccountId = platformCreditSalesAccountId;
            //Record the Payment
            console.log('RECORD PAY:', p);
            return fmm_recordPayment(p);
        })
        .then(function (record) {
            r.pl = record;
            deferred.resolve(record);
        })
        .catch(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}


/*
 * fmm_confirmCreditSale
 * Decrements systeam account and updates sell credits order once money has been successfuly
 * transferred from system Alipay account to the corporation's Alipay account.
 * @param {type} m{ pl:{orderId} }
 * @returns m{pl:{paymentOrderId,paymentOrderStatus,accountBalance},er:{error}}
 */
function fmm_confirmCreditSale(m) {
    var r = {"pl": null, "er": null};
    var p = {"pl": null, "er": null};
    var deferred = q.defer();
    sequelize.transaction(function (t) {
        //1. Find the order
        return paymentOrder.find({where: {id: m.pl.orderId}})
            .then(function (order) {
                p.pl = {
                    paymentOrderId: order.id,
                    transactionId: order.transactionId,
                    serviceName: 'CREDIT_PAYMENT',
                    destinationAccountId: alipayAccountId,
                    sourceAccountId: platformCreditSalesAccountId,
                    transactionAmount: order.orderAmount

                };
                //2. Find and decrement source account (withdrawal)
                return accountBalance.findOrCreate({where: {accountId: platformCreditSalesAccountId}, defaults: {accountType: 'admin'}}, {transaction: t})
                    .spread(function (user, created) {
                        return user.decrement(['accountBalance','totalCashOut'], {by: order.orderAmount, transaction: t});
                    });
            })
            .then(function (balance) {
                //3. Write transaction history
                p.pl.accountBalance = balance.accountBalance;
                return transactionHistory.findOrCreate({defaults: p.pl, where: {serviceName: p.pl.serviceName, paymentOrderId: p.pl.paymentOrderId, instanceId: 1, transactionId: p.pl.transactionId}}, {transaction: t});
            })
            .then(function () {
                //4. Update order status
                p.pl.paymentOrderStatus = 'paid';
                return fmm_updateOrderStatus({pl: {orderStatus: 'paid', where: {id: p.pl.paymentOrderId}}});
            });
    })
        .then(function () {
            r.pl = {
                paymentOrderId: p.pl.paymentOrderId,
                paymentOrderStatus: p.pl.paymentOrderStatus,
                accountBalance: p.pl.accountBalance
            };
            deferred.resolve(r);
        })
        .fail(function (error) {
            r.er = error;
            deferred.reject(r);
        });
}


/*
 * fmm_makeDirectPayment
 * Makes a payment to an order by using direct user credit. No Alipay process involved.
 * @param {type} m{pl:{transactionId}}
 * @returns {q@call;defer.promise}
 */
function fmm_makeDirectPayment(m) {
    var data,paymentOrderId,p,r={"pl": null, "er": null};
    return q().then(function(){
        data = m.pl;
        paymentOrderId = null;
        p = {pl: null, er: null};
        //If message object is empty, stop with error.
        if (typeof data.orders === 'undefined' || !data.orders.length) {
            r.er = "No parameters defined";
            return q.reject(r);
        }
        var promises = [];
        //1. Create all orders for each service
        data.orders.forEach(function (order) {
            var p = {pl: order, er: null};
            promises.push(fmm_createOrder(p));
        });
        return q.all(promises);
    })
        .then(function (order) {
            if(order)
            {
                var allNew = order.reduce(function(agg,ele){return ele.pl.isNew && agg },true)
                if(!allNew) throw "Order already exists"
            }
            var res = q();
            var initOrder;
            if (data.orders[0] instanceof Object) {
                initOrder = {};
                for (var attr in data.orders[0]) {
                    if (data.orders[0].hasOwnProperty(attr)) initOrder[attr] = data.orders[0][attr];
                }
            }
            initOrder.orderAmount = 0;
            initOrder.platformCommissionAmount = 0;
            initOrder.agentCommissionAmount = 0;
            initOrder.serviceName = initOrder.activityName;
            var reducedOrder = data.orders.reduce(function(agg, ele){
                //aggregate
                agg.orderAmount += ele.orderAmount;
                agg.platformCommissionAmount += ele.platformCommissionAmount;
                agg.agentCommissionAmount += ele.agentCommissionAmount;
                return agg;
            }, initOrder)
            data.orders = [reducedOrder];
            data.orders.forEach(function (row) {
                //2. Check if user has funds
                res = res.then(function () {
                    var p = {pl: {accountId: row.userAccountId}, er: null};
                    return fmm_getUserBalance(p);
                })
                    //3. Record Order Payment to system account
                    .then(function (balance) {
                        if (balance.accountBalance < row.orderAmount) {
                            r.er = 'Insufficient funds';
                            return q.fail(r);
                        }
                        p.pl = {
                            sourceAccountId: row.userAccountId,
                            destinationAccountId: platformAccountId,
                            serviceName: row.serviceName,
                            transactionId: row.transactionId,
                            paymentAmount: row.orderAmount,
                            paymentOrderId: row.id
                        };
                        return fmm_recordPayment(p);
                    })
                    //4. Update the order status to paid
                    .then(function () {
                        return fmm_updateOrderStatus({pl: {orderStatus: 'paid', where: {id: row.id}}});
                    });
            });
            return res;
        })
        .then(function (update) {
            r.pl = update;
            return q.resolve(r);
        })
        .then(null,function reject(error) {
            console.log("cancelling direct payment:",error);
            r.er = error;
            return q.reject(error);
        });
}


/* Step1:fmm_generateAlipayUrl
 * Creates orders when user clicks on make payment. On success returns new transactionId and orderAmount
 * @param Array orders[
 *                  serviceId, (required),
 *                  serviceName, (optional)
 *                  transactionId, (required)
 *                  serviceProviderId, (required)
 *                  orderAmount, (required)
 *                  platformComissionAmount, (required)
 *                  corporationId, (required)
 *                  affiliateId(optional),
 *                  affiliateCommissionAmount(optional),
 *                  ]
 *                  out_trade_no, (required)
 *                  subject, (required)
 *                  body [optional] ,
 *                  totalAmount (required)
 * @returns {q@call;defer.promise} Alipay compliant redirect URL
 *
 */
function fmm_generateAlipayUrl(m) {
    var data = m.pl;
    var paymentOrderId = null;
    data.orderStatus = 'pending';
    //Response
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    //If message object is empty, stop with error.
    if (typeof data.orders === 'undefined' || !data.orders.length) {
        r.er = "No parameters defined";
        deferred.reject(r);
        return deferred.promise;
    }
    var promises = [];
    data.orders.forEach(function (order) {
        var p = {pl: order, er: null};
        promises.push(fmm_createOrder(p));
    });
    q.all(promises)
        .then(function (order) {
            var sum = data.orders.reduce(function(sum, ele){return sum + ele.orderAmount},0);
            //Get the request parameters for Alipay form
            var alimsg = {pl: {
                out_trade_no: data.orders[0].transactionId + "T" + parseInt(new Date() / 1000, 10),//data.out_trade_no,
                subject: data.orders[0].activityName,
                price: sum,
                rc : data.orders[0].transactionId
            }, er: null};
            return alipay.getAlipayUrl(alimsg);
        })

        .then(function (url) {
            r.pl = {url: url.pl, paymentOrderId: paymentOrderId};
            deferred.resolve(r);
        })
        .fail(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}


/*
 * Step2: fmm_verifyAliPayment
 * User clicks on payment confirm button. Alipay transaction is checked with Alipay. If transaction was
 * successful transaction history is created and paymentOrder is updated.
 * @param transactionId
 * return aliPay Response
 */
function fmm_verifyAliPayment(m) {
    //Initialize Response
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    //TODO <assume verified>
    deferred.resolve({pl:"true"});
    return deferred.promise;
    //TODO </assume verified>
    //Set Alipay message
    var alimsg = {"pl": {}, "er": null};
    alimsg.pl.out_trade_no = m.pl.transactionId;
    //Verify Payment with Alipay
    alipay.verifyUserPayment(alimsg).then(function (response) {
        r.pl = response.pl;
        deferred.resolve(r);
    }).fail(function (error) {
        deferred.reject(error);
    });
    return deferred.promise;

}


/*
 * Step 3: fmm_splitPayment
 * After user has consumed all the services, total transaction amount should be split between the
 * service providers of a corporation. Loop through the paymentOrder table and make payments to all
 * the service providers belonging to a given transaction id.
 * @param transactionId
 * @return
 */
function fmm_splitPayment(m) {
    var r = {pl: null, er: null};
    var deferred = q.defer();
    var p = {pl: null, er: null};
    var promise = q();
    //Find all orders marked for splitting
    paymentOrder.findAll({where: {orderStatus: 'split'}, paymentType: 'online', transactionId: m.pl.transactionId})
        .then(function (rows) {
            if (rows.length === 0) {
                r.er = 'No rows marked for split!';
                deferred.reject(r);
            }
            rows.forEach(function (row) {
                //Record Order Payment to corporation
                promise = promise.then(function () {
                    if (row.orderAmount > 0) {
                        p.pl = {
                            sourceAccountId: platformAccountId,
                            destinationAccountId: row.corporationId,
                            serviceName: 'ORDER_PAYMENT',
                            transactionId: row.transactionId,
                            paymentAmount: row.orderAmount,
                            paymentOrderId: row.id,
                            accountType: 'corporation'
                        };
                        return fmm_recordPayment(p);
                    }
                    return promise;
                })
                    //Record Platform Commissions
                    .then(function () {
                        if (row.platformCommissionAmount > 0) {
                            p.pl = {
                                destinationAccountId: platformAccountId,
                                sourceAccountId: row.corporationId,
                                serviceName: 'PLATFORM_COMMISSION',
                                transactionId: row.transactionId,
                                paymentAmount: row.platformCommissionAmount,
                                paymentOrderId: row.id,
                                accountType: 'admin'
                            };
                            return fmm_recordPayment(p)
                                .then(function () {
                                    p.pl = {
                                        sourceAccountId: platformAccountId,
                                        destinationAccountId: platformCommissionAccountId,
                                        serviceName: 'COMMISSION_TRANSFER',
                                        transactionId: row.transactionId,
                                        paymentAmount: row.platformCommissionAmount,
                                        paymentOrderId: row.id,
                                        accountType: 'admin'
                                    };
                                    return fmm_recordPayment(p);
                                });
                        }
                        return q.resolve();
                    })
                    //Record Agent commissions
                    .then(function () {
                        if (row.agentCommissionAmount > 0) {
                            p.pl = {
                                destinationAccountId: row.agentId,
                                sourceAccountId: row.corporationId,
                                serviceName: 'AGENT_COMMISSION',
                                transactionId: row.transactionId,
                                paymentAmount: row.agentCommissionAmount,
                                paymentOrderId: row.id
                            };
                            return fmm_recordPayment(p);
                        }
                        return q.resole();
                    })
                    //Finally...Update account status to done!
                    .then(function () {
                        return paymentOrder.update({orderStatus: 'done'}, {where: {id: row.id}});
                    });
            });
            return q.resolve();
        })
        .then(function () {
            return paymentOrder.findAll({where: {orderStatus: 'paid', paymentType: 'offline', transactionId: m.pl.transactionId}});
        })
        .then(function (rows) {
            if (rows.length === 0) {
                r.er = 'No rows marked for split!';
                deferred.reject(r);
            }
            rows.forEach(function (row) {
                //Record Order Payment to corporation
                promise = promise.then(function () {
                    if (row.platformCommissionAmount > 0) {
                        p.pl = {
                            destinationAccountId: platformAccountId,
                            sourceAccountId: row.corporationId,
                            serviceName: 'PLATFORM_COMMISSION',
                            transactionId: row.transactionId,
                            paymentAmount: row.platformCommissionAmount,
                            paymentOrderId: row.id
                        };
                        return fmm_recordPayment(p)
                            .then(function () {
                                p.pl = {
                                    sourceAccountId: platformAccountId,
                                    destinationAccountId: platformCommissionAccountId,
                                    serviceName: 'COMMISSION_TRANSFER',
                                    transactionId: row.transactionId,
                                    paymentAmount: row.platformCommissionAmount,
                                    paymentOrderId: row.id
                                };
                                return fmm_recordPayment(p);
                            });
                    }
                })
                    .then(function () {
                        if (row.agentCommissionAmount > 0) {
                            p.pl = {
                                destinationAccountId: row.agentId,
                                sourceAccountId: row.corporationId,
                                serviceName: 'AGENT_COMMISSION',
                                transactionId: row.transactionId,
                                paymentAmount: row.agentCommissionAmount,
                                paymentOrderId: row.id
                            };
                            return fmm_recordPayment(p);
                        }
                        return promise;
                    })
                    //Finally...Update account status to done!
                    .then(function () {
                        return paymentOrder.update({orderStatus: 'done'}, {where: {id: row.id}});
                    });
            });
            return promise;
        })
        .then(function () {
            deferred.resolve(promise);
        })
        .fail(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}


/* Step1:fmm_generateAlipayUrl
 * Creates orders when user clicks on make payment. On success returns new transactionId and orderAmount
 * @param Array orders[
 *                  serviceId, (required),
 *                  serviceName, (optional)
 *                  transactionId, (required)
 *                  serviceProviderId, (required)
 *                  orderAmount, (required)
 *                  platformComissionAmount, (required)
 *                  corporationId, (required)
 *                  affiliateId(optional),
 *                  affiliateCommissionAmount(optional),
 *                  ]
 *                  out_trade_no, (required)
 *                  subject, (required)
 *                  body [optional] ,
 *                  totalAmount (required)
 * @returns {q@call;defer.promise} Alipay compliant redirect URL
 *
 */
function fmm_generateWechatPayUrl(m) {
    var data = m.pl;
    var paymentOrderId = null;
    data.orderStatus = 'pending';
    //Response
    var r = {"pl": null, "er": null};
    var deferred = q.defer();
    //If message object is empty, stop with error.
    if (typeof data.orders === 'undefined' || !data.orders.length) {
        r.er = "No parameters defined";
        deferred.reject(r);
        return deferred.promise;
    }
    var promises = [];
    data.orders.forEach(function (order) {
        var p = {pl: order, er: null};
        promises.push(fmm_createOrder(p));
    });
    q.all(promises)
        .then(function (order) {

          return  getwxOpenID(data.code).then(function(r){

              console.log('r open id----',r);

               return r;
            });


        })
        .then(function(openId){


            console.log('openId----',openId)

            var sum = data.orders.reduce(function(sum, ele){return sum + ele.orderAmount},0);
            //Get the request parameters for Alipay form
            //get open id needed..
            var wexinOrder = {
                body: '吮指原味鸡 * 1',
                attach: '{"部位":"三角"}',
                //out_trade_no: 'LZR1001' + weixinpay._generateTimeStamp(),
                out_trade_no: data.orders[0].transactionId + "T" + parseInt(new Date() / 1000, 10),//data.out_trade_no,
                total_fee: sum,
                spbill_create_ip: "127.0.0.1",
                openid: openId,
                trade_type: 'JSAPI'
            };
            var prom = q.defer();
            weixinpay.getBrandWCPayRequestParams(wexinOrder, function(err, payargs){
                console.log( payargs);
                //return q(payargs);
                if(err){
                    prom.reject(err);
                }
                //@ToDo check when payargs is empty
                else {
                    prom.resolve(payargs);
                }

            });
            return prom.promise;


        })
        .then(function (paymentArgument) {
            r.pl = paymentArgument;
            deferred.resolve(r);
        })
        .fail(function (error) {
            r.er = error;
            deferred.reject(r);
        });
    return deferred.promise;
}

exports.operations = [
    init,
    fmm_getPaymentOrders,
    fmm_sellCredits,
    fmm_confirmCreditSale,
    fmm_updateOrderStatus,
    fmm_splitPayment,
    fmm_alipayNotification,
    fmm_createAccount,
    fmm_createOrder,
    fmm_getUserBalance,
    fmm_getTransactionHistory,
    fmm_generateAlipayUrl,
    fmm_generateWechatPayUrl,
    fmm_verifyAliPayment,
    fmm_makeDirectPayment,
    fmm_recordPayment
];
// re-export ops (for testing)
exports.operations.forEach(function (op) {
    exports[op.name] = op;
});
