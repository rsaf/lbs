/**
 * Created by LBS006 on 12/1/14.
 */
var uuid = require('node-uuid');
var Q = require('q')
var formidable = require('formidable');
var fs = require('fs');
//var random = require('random.js');

function debuglog(){
    if(false)
        console.log.apply(this,arguments)
}
exports.createTransformjson = function(m)
{
    m.pl.ct = {uID:m.pl.uID , oID:m.pl.oID, cd: Date.now()};
    m.pl.md = {uID:m.pl.uID , oID:m.pl.oID, lu: Date.now()};
    delete m.pl['uID'];
    delete m.pl['oID'];
    return m;

}
/**
 * Returns true if obj is an array and false if it's not
 * @param {Object} obj
 * @returns {Boolean}
 */
exports.isArray = function isArray(obj){
  if(Object.prototype.toString.call(obj).indexOf('Array')!==-1){
    return true;
  }
  return false;
};
/**
 * Returns the index or indexes of an item in an array of objects
 * key: the key of the value to check, for example an array of objects
 *   having a name property the key will be name
 *   if multiple values need to be checked key can be ['firstName','lastName']
 *   now all objects in array will have their firstName and lastName properties
 *   checked with the values in val
 *   for comparing sub object like comparing street in {address:{street:'the value'}}
 *   the value for key used is: 'address.street'
 * val: the value to check so if the key is 'name' val can be 'Ben'
 *   if key is an array then val needs to be an array of same lenght
 *   for example key is ['firstName','lastName] then val can be:
 *   ['Ben','Sanders']
 * multiple: if this is true then eiter an empty array is returned or an array
 *   containing all the indexes of objects found
 * index: when true it will start looking from this index
 * strictly: when true if will compare obj[key]===val instead of the default obj[key]==val
 * @param {Array} arr
 * @param {String|Array(String)} key
 * @param {String|Array(String)} val
 * @param {Boolean} multiple
 * @param {Number} index
 * @returns {Number|Array(Number)}
 */
exports.find = function (arr,key,val,multiple,index,strictly){
  key = exports.isArray(key)?key:[key];
  val = exports.isArray(val)?val:[val];
  index = (index!==undefined)?index-1 : -1;
  var i = index,
    j = key.length,
    len = arr.length,
    compStrict=function(val1,val2){
      return val1===val2;
    },
    compEasy=function(val1,val2){
      return val1 == val2;
    },
    compfn=strictly?compStrict:compEasy,
    ok=true,
    ret = multiple?[]:-1;
    while(++i<len){
      j=key.length;
      ok=true;
      while(--j>-1){
        if(!compfn(exports.getMember(arr[i],key[j].split(".")),val[j])){
          ok=false;
          break;
        }
      }
      if(ok){
        if(multiple){
          ret.push(i);
        }else{
          return i;
        }
      }
    }
    return ret;
  }


/**
 * Returns the value for an object member if exist
 * for example object is {address:{street:'value of street'}}
 * if keys is ['address','street'] it will return 'value of street'
 * if keys is ['address'] it will return {street:'value of street'}
 * if keys is ['notexist'] it will return undefined
 * @param {Object} o
 * @param {Array(String)} keys
 * @returns {Any}
 */
exports.getMember = function getMember(o,keys){
    var i = -1, len = keys.length;
    while (++i < len) {
      o = o[keys[i]];
      if (o === undefined) {
        break;
      }
    }
    return o;
};


exports.updateTransformjson =  function(m)
{
    m.pl.md = {uID:m.pl.uID , oID:m.pl.oID, lu: Date.now()};
    delete m.pl['uID'];
    delete m.pl['oID'];
    return m;

}

exports.findIndex = function(arg){
        var arr = arg.arr,
            key = arg.key,
            val = arg.val,
            index = arg.index || 0,
            i = index - 1,
            len = arr.length,
            multiple = arg.multiple,
            ret = multiple?[]:-1;
        while(++i<len){
            if(arr[i][key]===val){
                if(multiple){
                    ret.push(i);
                }else{
                    return i;
                }
            }
        }
        return ret;
}

exports.spliceItem = function(arg ){
 return paramArrary.splice(arg.index,arg.Number);
}

exports.removeItem = function(arg, callback){
    var arr = arg.arr,
        key = arg.key,
        val = arg.val,
        i = - 1,
        len = arr.length;

    while(++i<len){
        if(arr[i][key]===val){
            arr.splice(i);
            return callback (null, arr);
            }
    }
   return callback('item not found', null);
}

exports.transactionHelper = require('./transactionHelper.js');


exports.getUuidFromUri = function(uri){

    //uri format handled: /photos/55681405-97db-468c-893b-40e0501172df.jpeg or  55681405-97db-468c-893b-40e0501172df.jpeg

    return uri.slice(uri.lastIndexOf('/')+1,uri.lastIndexOf('.'));
}

exports.getExtensionFromUri = function(uri){
    return uri.split('.').pop();
}


exports.generateResponseReferenceCode = function(seed){
    //TODO: make this based on phone and response code

    var base = "23456789QWERTPASDFGHJKZCBNM";
    for(var code = ""; code.length < 6;)
    {
        code += base[Math.floor(Math.random() * base.length)]
    }
    return code;
}

exports.generateTransactionReferenceCode = function(seed){
    var base = "23456789QWERTPASDFGHJKZCBNM";
    for(var code = ""; code.length < 6;)
    {
        code += base[Math.floor(Math.random() * base.length)]
    }
    return code;
}

exports.prepopulateMongoDatabase = function(mongo_init_json, transactionHelper){
    var p = new Array();
    var idx = new Array();
    var credential = new exports.Credential(undefined,"200000000000000000000000");
    //An init json is an object mapping (collection names) -> (arrays of documents to populate collection with)
    //NOTE!!! --- These arrayed documents USE THEMSELVES AS QUERIES to see if they already exist- Avoid _id in the json!
    for (var key in mongo_init_json) {
        if (!mongo_init_json.hasOwnProperty(key)) continue;
        var fnPromise = function fnPromise(index, tgtColl) {
                var tgtSrc = mongo_init_json[tgtColl];
                var crit = {};
                crit[tgtSrc.preexistenceCriterion] = tgtSrc.docs[index][tgtSrc.preexistenceCriterion];
                return transactionHelper.getCreate(tgtColl, {}, false, crit, true,credential)
                    .then(function resolve(result) {
                        if (!result.isNew) return;

                        var ele = tgtSrc.docs[index];
                        for (var key in ele) {
                            result[key] = ele.hasOwnProperty(key) ? ele[key] : result[key];
                        }
                        return transactionHelper.saveToPromise(result);
                    }, function failure(result) {
                        console.log("rejection?", result);
                    });
        }
        for (var i = 0; i < mongo_init_json[key].docs.length; i++) {
            idx.push(i);
            p.push(fnPromise(i,key));
        }
    }
    //Take list of document creation promises and execute them all
    return Q.all(p)
        .then(function resolve(r) {
            return Q.resolve({pl:r,er:null});
        }, function failure(err) {
            return Q.reject({pl:err,er:err});
        });
}

exports.digFor = function(obj,path,isType){
    var segs = path.split(".");
    if(!obj) return undefined;

    var lvl = obj;
    for(var i = 0; i < segs.length; i ++)
    {
        lvl = obj[segs[i]];
        if(lvl === undefined) return undefined;
    }
    if(!isType || (isType && typeof lvl === isType))
        return lvl;
}

// Returns a random integer between min (included) and max (excluded)
// Using Math.round() will give you a non-uniform distribution!

exports.generateRandomValue = function(arg){

    var arg = arg||{min:111111,max:999999};

    var min = arg.min;
    var max = arg.max;
    var value =   Math.floor(Math.random() * (max - min)) + min;
    return value;

}

exports.permissionsSchema = function(permissionDefaults)
{
    if(permissionDefaults === undefined) permissionDefaults = {};
    return {

        own : {
            uid: {select: false, type:String},
            p: {default: permissionDefaults.own !== undefined ? permissionDefaults.own : "rwd" ,select: false,type:String}
        },
        grp : {
            uid: {select: false, type:String},
            p: {default: permissionDefaults.grp !== undefined ? permissionDefaults.grp : "rwd" ,select: false,type:String}
        },
        lzm:{
            val : {select: false, type:String},
            p: {default: permissionDefaults.lzm !== undefined ? permissionDefaults.lzm : "rwd" ,select: false,type:String}
        },
        all:{
            p: {default: permissionDefaults.all !== undefined ? permissionDefaults.all : "rwd" ,select: false,type:String}
        }
    }
}

exports.secAccRead = ["r","rw","wr","rd","dr","rwd","wdr","drw","wrd","dwr","rdw"];
exports.secAccWrite = ["w","rw","wr","wd","dw","rwd","wdr","drw","wrd","dwr","rdw"];
exports.secAccRemove = ["d","wd","dw","rd","dr","rwd","wdr","drw","wrd","dwr","rdw"];
exports.Credential = function(user, group, lzm){
    //console.log("creating credential with",user,group,lzm)
    this.user = user;
    this.organization = group;
    this.lzm = lzm;
}
exports.authTransform = function(query, op, cred){
    cred = typeof cred === 'object' ? cred : {};

    var opClause = {},
        user = cred.user,
        organization = cred.organization,
        lzm = cred.lzm;

    if(op == "r")//read
    {
        opClause["$in"] = exports.secAccRead;
    }
    else if(op == "w")//update
    {
        opClause["$in"] = exports.secAccWrite;
    }
    else if(op == "d")//delete
    {
        opClause["$in"] = exports.secAccRemove;
    }
    var usrClause = {$and : [{"s.own.uid":user}, {"s.own.p":opClause}]},
        orgClause = {$and : [{"s.grp.uid":organization}, {"s.grp.p":opClause}]},
        pubClause = {"s.all.p":opClause},
        lzmClause = {$and : [{"s.lzm.val": lzm}, {"s.lzm.p":opClause}]},
        orClause = [pubClause],
        result = undefined;

    if(user !== undefined) orClause.push(usrClause);
    if(organization !== undefined) orClause.push(orgClause);
    if(lzm !== undefined) orClause.push(lzmClause);

    if(organization == "200000000000000000000000")
        result = query;
    else if(query == {})
        result = {$or: orClause};
    else
        result = {$and : [query, {$or:orClause}]};

    //console.log("AUTH TRANSFORM YIELDS:\n",JSON.stringify(result),"\n(End Auth on",user,organization,lzm,")");
    return result;
}

exports.WorkflowManager = function(arg){
    var esbMessage = arg.esbMessage,
        _commitTransaction = arg.commitTransaction,
        _rollbackTransaction = arg.rollbackTransaction,
        me = this;

    me.completeService = function _onServicePerformed(responseCode, serviceCode, payload, user, scheduleNext) {
        var ln = user && user.lanzheng ? user.lanzheng.loginName : undefined,
            co = user ? user.currentOrganization : undefined,
            transactionid,
            service,
            enq,
            idx,
            responseInfo;

        function findFirstIndex(array, callback) {
            for (var i = 0; i < array.length; i++) {
                if (callback(array[i])) return i;
            }
            return -1;
        }

        /*
         When a service is completed, the following things must occur:

         - The service in question must have its status set to 'PERFORMED'
         - The business record associated with the service must be set to 'PERFORMED'
         - The service must then have its status set to 'PROCESSED'
         */

        var deferred = Q.defer();

        Q()
            //START TRANSACTION
            .then(function () {
                debuglog("on Perform: Create transaction with loginName:",ln);
                return esbMessage({
                    op: "createTransaction",
                    pl: {
                        loginName: ln,
                        currentOrganization: co,
                        transaction: {
                            description: 'Record service performance'
                            , modules: ['bmm', 'smm']
                        }
                    }
                })
            })
            //GET SERVICE INFO
            .then(function (tid) {
                transactionid = tid.pl.transaction._id;
                debuglog("on Perform: getting service")
                return esbMessage({
                    ns: "smm",
                    op: "smm_getService",
                    pl: {
                        code: serviceCode,
                        loginName: ln,
                        currentOrganization: co
                    }
                })
            })
            //FETCH RESPONSE INFO
            .then(function (serviceResponse) {
                service = serviceResponse.pl.toObject();
                debuglog("on Perform: getting response")
                return esbMessage({
                    ns: "bmm",
                    op: "bmm_getResponse",
                    pl: {
                        code: responseCode,
                        loginName: ln,
                        currentOrganization: co
                    }
                });
            })
            //UPDATE RESPONSE STATUS TO 'PERFORMED'
            .then(function (response) {
                responseInfo = response;
                idx = response && response.sb && response.sb.length > 0
                    ? findFirstIndex(response.sb, function (e) {
                    return (true || e.svid == service._id) && e.cvs == 20
                })//IS ISSUED
                    : -1;
                debuglog("on Perform: persisting service",idx)
                if (idx >= 0) {
                    response.sb[idx].cvs = 40;//PERFORMED
                    response.sb = response.sb[idx]
                    var rpl = response;
                    return esbMessage({
                        "ns": "bmm",
                        "op": "bmm_persistResponse",
                        "pl": {
                            response: rpl,
                            loginName: ln,
                            currentOrganization: co
                        }
                    });
                }
                else throw {pl: null, er: {em: "Invalid service performance - request not issued", ec: 1567}};
            })
            //PROCESS PERFORMANCE (BUSINESS RECORD)
            .then(function (esbResponse) {

                var var_spt = new Date();

                debuglog("on Perform: spawn business record")
                return esbMessage({
                    ns: "smm",
                    op: "smm_spawnBusinessRecord",
                    pl: {
                        response: {
                            acn: responseInfo.acn//activity name
                            , rc: responseCode//response code
                            , serviceCode: serviceCode// service code
                            , svn: service.serviceName// service name code
                            , st: 50//IS PROCESSED
                            , spt: var_spt
                            , uid: ln// user login account , customer who bought the service
                            , usn: responseInfo.ow.uid// user name , customer who bought the service
                            , svp: responseInfo.sb.svp//
                            , service: service._id//{ type: paramMongoose.Schema.Types.ObjectId, ref: 'services',required:true }
                            , oID: service.ct.oid
                        },
                        loginName: ln,
                        currentOrganization: co,
                        transactionid: transactionid
                    }
                })
            })
            //FETCH RESPONSE INFO
            .then(function (processResponse) {
                debuglog("on Perform: getting second response")
                return esbMessage({
                    ns: "bmm",
                    op: "bmm_getResponse",
                    pl: {
                        code: responseCode,
                        loginName: ln,
                        currentOrganization: co
                    }
                });
            })
            //UPDATE RESPONSE STATUS TO 'PROCESSED'
            .then(function (response) {
                idx = response && response.sb && response.sb.length > 0
                    ? findFirstIndex(response.sb, function (e) {
                    return (true || e.svid == service._id) && e.cvs == 40
                })//IS PERFORMED
                    : -1;
                if (idx >= 0) //This service has been processed and seen satisfactory
                {
                    response.sb[idx].cvs = 50;//PROCESSED
                    response.sb[idx].cvt = new Date();
                    response.sb = response.sb[idx];
                    debuglog("on Perform: updating response to done")
                    return esbMessage({
                        "ns": "bmm",
                        "op": "bmm_persistResponse",
                        "pl": {
                            response: response,
                            loginName: ln,
                            currentOrganization: co
                        }
                    })
                }
                else  throw {pl: null, er: {em: "Invalid service performance - failed processing", ec: 1568}};
            })
            //COMMIT TRANSACTION
            .then(function (esbResponse) {
                enq = esbResponse;
                if (transactionid) {
                    debuglog("on Perform: committing transaction")
                    return _commitTransaction({pl: {transactionid: transactionid}});
                }
                return false;
            })
            //RUN AUTOMATION IF SPECIAL
            .then(function (r){

                var sv_code = serviceCode;
                var isSpecial = -1;
                for(var i = 0; i < me.specialCases.cases.length; i++)
                {
                    var tgt = me.specialCases.cases[i];
                    if(!sv_code  || tgt.sv != sv_code) continue;
                    isSpecial = i;
                    break;
                }
                if(isSpecial >= 0)
                {
                    debuglog("Doing special case",isSpecial,"onPerform");
                    return me.specialCases.cases[isSpecial].onPerform(payload, user, responseInfo, transactionid);
                }
                return {pl: r, er: null};
            })
            //RESOLVE & SCHEDULE NEXT
            .then(function resolve(r) {
                debuglog("onPerform: response is",r)
                deferred.resolve(r);
                if(scheduleNext)
                    return me.scheduleService(responseCode,{}, user).then(function(sh){debuglog("ScheduleNext honored with reply:",sh)});

            }, function failure(r) {
                console.log("Rolling back service performance transaction. Failure : ", r);
                return _rollbackTransaction({pl: {transactionid: transactionid}})
                .then(function goodRollback(){
                    console.log("Rollback succeeded");
                        deferred.reject(r)
                }  ,  function badRollback(e){
                    console.log("Rolling back service performance transaction. Failure : ", r,e);
                    deferred.reject(r)//{pl: null, er:{ec:999,em:"Initial failure"+JSON.stringify(r)+"compounded with rollback error"+JSON.stringify(e)}});
                })

            });

        return deferred.promise;
    }

    me.scheduleService = function triggerNextService(responseCode, payload, user) {
        var ln = user.lanzheng.loginName,
            org = user.currentOrganization,
            responseCode = responseCode,
            transactionid,
            service,
            oldsb,
            responseInfo,
            tgtScheduleIdx = 0,
            IS_COMPLETE = false;//default to doing first service
        debuglog("onSchedule: scheduling next service of",responseCode,". Payload: ",payload);

        /*
         When the next service in the workflow needs to be scheduled, the following things must occur:

         - Create a Transaction
         - Find the next service in the workflow
         - Set this service's status from 'Pending' to 'Issued'
         - Generate and send a Business Record for the service
         - Run any automation code that is required
         */

        return Q()
            //INIT TRANSACTION
            .then(function () {
                debuglog("onSchedule: ","creating transaction");
                return esbMessage({  //and a transactionid
                    op: "createTransaction",
                    pl: {
                        loginName: ln,
                        currentOrganization: org,
                        transaction: {
                            description: 'Notify service point of response intent'
                            , modules: ['bmm', 'smm']
                        }
                    }
                })
            })
            //FETCH RESPONSE STATUS FROM CODEs
            .then(function (tid) {
                transactionid = tid.pl.transaction._id;
                debuglog("onSchedule: ","getting response");
                return esbMessage({
                    ns: "bmm",
                    op: "bmm_getResponse",
                    pl: {
                        code: responseCode,
                        loginName: ln,
                        currentOrganization: org,
                        transactionid: transactionid
                    }
                });
            })
            //DETERMINE NEXT VALID SERVICE
            .then(function (esbResponse) {
                responseInfo = esbResponse;

                if (!responseInfo)
                    throw {pl: null, er: {ec: 1920, em: "No response passed."}};
                //No new services to process
                else if (!responseInfo.sb || responseInfo.sb.length == 0 || responseInfo.rs == 45)
                    return false;

                tgtScheduleIdx = esbResponse.sb.reduce(
                    function (agg, ele, idx) {
                        if (agg == null && ele.cvs == 10) //find first PENDING(10) service
                            return idx;
                        return agg;
                    }, null);
                if (!responseInfo.sb[tgtScheduleIdx])
                    return false;
                else if (responseInfo.sb[tgtScheduleIdx].cvs != 10)
                    throw {
                        pl: null,
                        er: {
                            ec: 1923,
                            em: "Attempting to issue a " + responseInfo.sb[tgtScheduleIdx].cvs + " service. Must be PENDING (10)."
                        }
                    };
                else return true;
            })
            //GET SERVICE
            .then(function(serviceAvailable){

                debuglog("onSchedule: ","getting service",serviceAvailable);
                if(serviceAvailable === false){
                    debuglog("THIS RESPONSE IS COMPLETE: FLOWING OUT. Response is:",responseInfo);
                    IS_COMPLETE = true;
                    if(responseInfo.rs != 45)
                        return Q().then(function(){return me.finish(responseCode, payload, user, transactionid)});
                    else
                        return false;
                }
                return esbMessage({
                    ns: "smm",
                    op: "smm_getService",
                    pl: {
                        qid: responseInfo.sb[tgtScheduleIdx].svid,
                        loginName: ln,
                        currentOrganization: org,
                        transactionid: transactionid
                    }
                })
            })
            //SPAWN BUSINESS RECORD
            .then(function (serviceResponse) {
                if (IS_COMPLETE) return serviceResponse;//no service to issue
                service = serviceResponse.pl;
                debuglog("onSchedule: ","spawning busines record");
                return esbMessage({
                    ns: "smm",
                    op: "smm_spawnBusinessRecord",
                    pl: {
                        response: {
                            acn: responseInfo.acn//activity code
                            , btc: exports.generateTransactionReferenceCode()
                            , rc: responseCode//response code
                            , serviceCode: service.serviceCode// service code
                            , svn: service.serviceName// service name code
                            , st: 20// status
                            , uid: ln// user login account , customer who bought the service
                            , usn: responseInfo.ow.uid// user name , customer who bought the service
                            , svp: responseInfo.sb[tgtScheduleIdx].svp//
                            , service: service._id//{ type: paramMongoose.Schema.Types.ObjectId, ref: 'services',required:true }
                            , oID: service.ct.oID
                        },
                        loginName: ln,
                        currentOrganization: org,
                        transactionid: transactionid
                    }
                });
            })
            //SET SERVICE TO 'ISSUED'
            .then(function (businessRec) {
                if(IS_COMPLETE) return businessRec;
                if (exports.digFor(responseInfo, "sb.length") <= 0 || !businessRec) return false;//no service

                if(tgtScheduleIdx-1 >= 0)responseInfo.sb[tgtScheduleIdx-1].cvs = 50;//todo: check if actually succeeded

                responseInfo.sb[tgtScheduleIdx].cvs = 20;
                oldsb = responseInfo.sb;
                responseInfo.sb = responseInfo.sb[tgtScheduleIdx];
                debuglog("onSchedule: ","persisting response to issued");
                return esbMessage({
                    "ns": "bmm",
                    "op": "bmm_persistResponse",
                    "pl": {
                        transactionid : transactionid,
                        response: responseInfo,
                        loginName: ln,
                        currentOrganization: org
                    }
                });
            })
            //COMMIT TRANSACTION
            .then(function (serviceAvailable) {
                if(IS_COMPLETE) return serviceAvailable;
                responseInfo.sb = oldsb;
                //TODO handle no-service case
                if (transactionid) {
                    debuglog("onSchedule: ","commiting transaction");
                    return _commitTransaction({pl: {transactionid: transactionid}});
                }
                return false;
            })
            //RUN AUTOMATION IF SPECIAL
            .then(function(r){
                if(IS_COMPLETE) return r;
                var sv_code = responseInfo && responseInfo.sb && responseInfo.sb[tgtScheduleIdx] ? responseInfo.sb[tgtScheduleIdx].serviceCode : undefined;
                var isSpecial = -1;
                for(var i = 0; i < me.specialCases.cases.length; i++)
                {
                    var tgt = me.specialCases.cases[i];
                    if(!sv_code  || tgt.sv != sv_code) continue;
                    isSpecial = i;
                    break;
                }
                if(isSpecial >= 0) {
                    debuglog("onSchedule: ","scheduling special case",isSpecial);
                    return me.specialCases.cases[isSpecial].onSchedule(payload, user, responseInfo, transactionid);
                }
                return r
            })
            //EXIT
            .then(function resolve(r) {
                if(IS_COMPLETE)
                {
                    debuglog("Response already closed");
                    return {pl:{IS_COMPLETE:true}};
                }
                debuglog("onSchedule: ","done with",r);
                return {pl:r};
            }, function failure(r) {
                console.log("Unable to issue order (rolling backz):", r);
                _rollbackTransaction({pl: {transactionid: transactionid}});
                return r
            });
    }

    me.finish = function finishWorkflow(responseCode, payload, user, transactionid){
        debuglog("COMPLETING WORKFLOW!");
        return esbMessage({
            ns: "bmm",
            op: "bmm_getResponse",
            pl: {
                code: responseCode,
                loginName: user.lanzheng.loginName,
                currentOrganization: user.currentOrganization,
                transactionid: transactionid
            }
        })
        //CLOSE RESPONSE
        .then(function(response){
            var mut = {
                _id : response._id,
                rs : 45
            }
            if(response && response.sb)
            {
                var needsURIChange = ["LZS102","LZS105","LZS106"];
                for(var i = 0; i < response.sb.length; i ++)
                {
                    for(var j = 0; j < needsURIChange.length; j++)
                    {
                        if(needsURIChange[j] == response.sb[i].serviceCode)
                        {
                            console.log('alal',response.fd.pt)
                            response.fd.pt[0].pp.uri = response.fd.pt[0].pp.urll.replace("_l.",".");
                            mut.fd = {pt:[{pp:response.fd.pt[0].pp}]};
                            break;
                        }
                    }
                }
            }
            return esbMessage({
                "ns":"bmm",
                "op":"bmm_persistResponse",
                "pl":{
                    transactionid : transactionid,
                    loginName : user.lanzheng.loginName,
                    currentOrganization : user.currentOrganization,
                    response : mut
                }
            })
        })
            //RUN AUTOMATION IF SPECIAL
            .then(function(altresponse){
            var isSpecial = -1;
            for(var i = 0; i < me.specialCases.cases.length; i++)
            {
                var tgt = me.specialCases.cases[i];
                if(altresponse.pl.acn != tgt.ac) continue;
                isSpecial = i;
                break;
            }
            if(isSpecial >= 0) me.specialCases.cases[isSpecial].onComplete(responseCode, user, altresponse);
            return altresponse;
        })
    };

    me.specialCases = new exports.specialCases(esbMessage, me.completeService,me.scheduleService, _commitTransaction, _rollbackTransaction);
}

exports.specialCases = function(esbMessage, performFn, triggerFn, commitFn, rollbackFn){
    var me = this;

    //

    // LZB 101 - Individual ID Validation

    //
    var _scheduleLZS101 = function _scheduleIDValidationHook(payload, user,responseObj,transactionid){
        var ac_code = exports.digFor(responseObj,"acn"),
            sv_code = exports.digFor(responseObj,"sb.0.svn"),
            responseObjectToReturn;

        return Q()
            //Hit UPM to validate
            .then(function(){
                return esbMessage({
                    ns:"upm",
                    op:"upm_validateUserInfo",
                    method:"validateID",
                    skipProfileUpdate: ac_code == "LZB107" ? true : false,
                    pl:{
                        loginName : user.lanzheng.loginName,
                        currentOrganization : user.currentOrganization,
                        "transactionid":transactionid,
                        "sfz": responseObj.fd.fields["LZSID"], //shenfenzheng or user national id number
                        "xm": responseObj.fd.fields["LZNAME"],  //xingming or user full name
                        "zz": ""   //zhengzhao or user id photo buffer //must be provided when executing the validatePhoto method.
                    }
                });
            })
            //Update response Status
            .then(function (r) {
                if(responseObj.ow && responseObj.fd && responseObj.fd.fields)
                    responseObj.ow.lzsid = responseObj.fd.fields.LZSID
                return esbMessage({
                    "ns": "bmm",
                    "op": "bmm_persistResponse",
                    "pl": {
                        transactionid: transactionid,
                        loginName: user.lanzheng.loginName,
                        currentOrganization: user.currentOrganization,
                        response: {
                            _id: responseObj._id,
                            //rs: 45,
                            ow: responseObj.ow,
                            rfc: responseObj.rfc,
                            fd: r && r.pl ?
                                {fields:
                                    {
                                        //LZBIZCODE: r.pl.LZBIZCODE,  // error code
                                        LZGMSFHM: r.pl.LZGMSFHM, // validation result of the id number
                                        LZBIZDESC:r.pl.LZBIZDESC, // validation result discription
                                        //LZNAME:r.pl.LZNAME,  // name to be validated
                                        LZXM:r.pl.LZXM // validation result of the name
                                        //LZXP:r.pl.LZXP,
                                        //LZSID:r.pl.LZSID // id to be validated
                                    }
                                } : undefined
                        }
                    }
                })
            })
            //Immediately schedule next service
            .then(function(r){
                return me.perform(responseObj.rc, "LZS101", {}, user, "DO_NEXT")
            })
            //EXIT
            .then(function resolve(r){
                responseObjectToReturn = {pl:r,er:null};
                return responseObjectToReturn;
            }  ,  function failure(r){
                console.log("Unable to issue (special case) order (rolling back):",r);
                return me.rollback({pl:{transactionid : transactionid.pl.transaction._id}});
            });
    };
    var _performLZS101 = function _scheduleIDValidationHook(payload, user, responseObj, transactionid){
        return Q().then(function(){console.log("Perform stub for id val"); return {pl:null, er:null};})
    };
    var _completeLZS101 = function(){
        return Q().then(function(){console.log("ALL COMPLETED LZB101")})
    };

    //

    // LZB 102 - Individual Photo Validation

    //
    var _scheduleLZS102 = function _schedulePhotoValidationHook(payload, user,responseObj, transactionid){
        var ac_code = exports.digFor(responseObj,"acn"),
            sv_code = exports.digFor(responseObj,"sb.0.svn"),
            responseObjectToReturn;

        return Q()
            //Hit UPM to validate
            .then(function(){
                console.log('PT:',responseObj.fd.pt);
                return esbMessage({
                    "transactionid" : transactionid,
                    ns:"upm",
                    op:"upm_validateUserInfo",
                    "method":"validatePhoto",
                    pl:{
                        loginName : user.lanzheng.loginName,
                        currentOrganization : user.currentOrganization,
                        "sfz": responseObj.fd.fields["LZSID"],
                        "xm" : responseObj.fd.fields["LZNAME"],
                        "zz" : responseObj.fd.pt[0].pp
                    }
                })
            })
            //Update response Status
            .then(function (r) {
                console.log("User is",user);
                return esbMessage({
                    "ns": "bmm",
                    "op": "bmm_persistResponse",
                    "pl": {
                        transactionid: transactionid,
                        loginName: user.lanzheng.loginName,
                        currentOrganization: user.currentOrganization,
                        response: {
                            _id: responseObj._id,
                            //rs: 45,
                            rfc: responseObj.rfc,
                            fd: r && r.pl ?
                                {
                                    fields: {
                                        //heyanjieguo: r.pl.LZBIZDESC
                                        //LZBIZCODE: 'NO',    // error code
                                        LZGMSFHM: r.pl.LZGMSFHM, // validation result of the id number
                                        LZBIZDESC: r.pl.LZBIZDESC, // validation result discription
                                        LZXPFS: r.pl.LZXPFS, //similirity number
                                        //LZNAME: r.pl.LZNAME, // name to be validated
                                        LZXM: r.pl.LZXM, // validation result of the name
                                        LZXPFX: r.pl.LZXPFX, // conclusion of validation
                                        //LZSID: r.pl.LZSID // id to be validated }
                                    }
                                } : undefined
                        }
                    }
                })
            })
            //Immediately schedule next service
            .then(function(r){
                responseObjectToReturn = {pl:r,er:null};
                return me.perform(responseObj.rc, "LZS102", {}, user, "DO_NEXT")
            })
            //EXIT
            .then(function resolve(r){
                return responseObjectToReturn;
            }  ,  function failure(r){
                console.log("Unable to issue (special case) order (rolling back):",r,". Transaction id: ",transactionid);
                return me.rollback({pl:{transactionid : transactionid.pl.transaction._id}});
            });
        /*
         //EXIT
         .then(function resolve(r){
         return r;
         }  ,  function failure(r){
         console.log("Unable to issue (special case) order (rolling back):",r);
         return _rollBackTransaction({pl:{transactionid : transactionid.pl.transaction._id}});
         });*/
    };
    var _performLZS102 = function _performPhotoValidationHook(payload, user, responseObj, transactionid){
        return Q().then(function(){console.log("perform stub for photo val"); return {pl:null, er:null};})
    };
    var _completeLZS102 = function(){
        return Q().then(function(){console.log("ALL COMPLETED LZB102")})
    };

    //

    // LZB 103 - Corporate Validation

    //
    var _scheduleLZS103 = function _scheduleCorporateValidationHook(payload, user,responseObj, transactionid){
        var responseObjectToReturn;
        function _initRequestMessage(user,type,code,adminOrg,orgName){
            var col,mod='upm',
                message,url;
            if(type==='Response'){
                col='responses';
                url='/processes/activities/application';
                message="认证";
            }

            return {
                rdo: adminOrg
                ,rc: 'code'
                ,rt: message + '申请 ' + code
                ,rsu: user.lanzheng.loginName
                ,rso: user.currentOrganization
                ,rs: 10
                ,ric:orgName||''
                ,rb: '请审核单位认识申请，拼同意或者拒绝'
                ,rtr: type
                ,ei:[{
                    col:col
                    ,mod:mod
                    ,ei:code
                }]
                ,url:url,
                "md" : {
                    "uID" : "a1ed",
                    "oID" : "200000000000000000000000"
                },
                "ct" : {
                    "uID" : "a1ed",
                    "oID" : "200000000000000000000000"
                }
            };
        }
        return Q()
            .then(function(){
                return esbMessage({op:'getOrganization',pl:{org:'lanzheng',
                    loginName : user.lanzheng.loginName,
                    currentOrganization : user.currentOrganization}})
            })
            //Generate request
            .then(function(adminid){
                return esbMessage({
                    "ns":"rmm",
                    "op":"rmm_persistRequestMessage",
                    "pl": {
                        request: _initRequestMessage(user,"Response",responseObj.rc,adminid.pl.oID),
                        loginName : user.lanzheng.loginName,
                        currentOrganization : user.currentOrganization
                    }
                });
            })
            //EXIT
            .then(function resolve(r){
                responseObjectToReturn = {pl:responseObj,er:null};
                console.log("DID THE CORPORATE VALIDATION RESPONSE");
                return responseObjectToReturn;
            }  ,  function failure(r){
                console.log("Unable to issue (special case -> Corporate Validation) order (rolling back):",r);
                return me.rollback({pl:{transactionid : transactionid.pl.transaction._id}});
            });
    };
    var _performLZS103 = function _performCorporateValidationHook(payload, user, responseObj, transactionid){
        return Q().then(function(){console.log("perform stub for corp val"); return {pl:null, er:null};})
    };
    var _completeLZS103 = function(){
        return Q().then(function(){console.log("ALL COMPLETED LZB103")})
    };

    //

    // LZB 104 - Corporate Credit Purchase

    //
    var _scheduleLZS104 = function _scheduleCorporateCreditPurchaseHook(payload, user,responseObj,transactionid){
        var responseObjectToReturn;

        return Q()
            //Add Money
            .then(function(adminid){
                console.log("skipping direct payment");
                return;
            })
            //Immediately schedule next service
            .then(function(r){
                return me.perform(responseObj.rc,"LZS104",{}, user,"DO_NEXT");
            })
            //EXIT
            .then(function resolve(r){
                responseObjectToReturn = {pl:r,er:null};
                return responseObjectToReturn;
            }  ,  function failure(r){
                console.log("Unable to issue (special case -> Credit Purchase) order (rolling back):",r);
                return me.rollback({pl:{transactionid : transactionid.pl.transaction._id}});
            })
    };
    var _performLZS104 = function _performCorporateCreditPurchaseHook(payload, user, responseObj, transactionid){
        return Q().then(function(){console.log("perform stub for credit"); return {pl:null, er:null};})
    };
    var _completeLZS104 = function(){
        return Q().then(function(){console.log("ALL COMPLETED LZB104")})
    };

    //

    // LZB 105 - Photo Inspection

    //
    var _scheduleLZS105 = function _schedulePhotoInspectionHook(payload, user, responseObj, transactionid){
        var ac_code = exports.digFor(responseObj,"acn"),
            sv_code = exports.digFor(responseObj,"sb.0.svn"),
            responseObjectToReturn = {pl: {}, er:null};
        return Q()
            .then(function getPhotoInfo(){
                var tgtURLS;
                if(responseObj && responseObj.fd && responseObj.fd.pt && responseObj.fd.pt[0] && responseObj.fd.pt[0].pp)
                    tgtURLS = responseObj.fd.pt[0].pp.urls
                return esbMessage({
                    "ns":"pmm",
                    "op":"pmm_getPhotoByUri",
                    "pl":{
                        ac: ac_code ,
                        uri: tgtURLS?tgtURLS.replace("_s",""):undefined,
                        loginName : user.lanzheng.loginName,
                        currentOrganization : user.currentOrganization
                        //sg: 10
                    }
                })
            })
            .then(function(photo){
                photo.pl.loginName = user.lanzheng.loginName;
                photo.pl.currentOrganization = user.currentOrganization;
                return esbMessage({
                    ns: 'pmm',
                    op: "pmm_SubmitPhotoToInspection",
                    pl: photo.pl
                })
            })
            .then(function resolve(r){
                console.log("Scheduled photo inspection");
                return responseObjectToReturn;
            }  ,  function failure(r){
                console.log("Unable to issue (special case) order (rolling back):",r);
                return me.rollback({pl:{transactionid : transactionid.pl.transaction._id}});
            });
    };
    var _performLZS105 = function _performPhotoInspectionHook(payload, user, responseObj, transactionid){
        if (payload.status === 'qualified') {

            payload.photo.st = '300';

        }
        else if (payload.status === 'unqualified') {

            payload.photo.st = '400';
        }
        else {
            //Error
            return {pl : null, er : "Unknown inspection photo type '"+payload.status+"'"}
        }
        payload.photo.loginName = user.lanzheng.loginName;
        payload.photo.currentOrganization = user.currentOrganization;
        console.log("Setting Inspected Photo Status");
        return esbMessage({
            ns: 'pmm',
            op: "pmm_SetInspectedPhotoStatus",
            pl: payload.photo
        })
            .then(function (r) {
                //todo update sms account
                if (payload.status === 'unqualified') {
                    esbMessage({
                        ns : "mdm",
                        op : "sendNotification",
                        vs : "1.0",
                        pl : {
                            recipients: payload.recipients,
                            notification: payload.notification,
                            loginName : user.lanzheng.loginName,
                            currentOrganization : user.currentOrganization
                        }
                    })
                }
                return r;
            })
            .then(function (r) {
                console.log("Successful Photo Inspection Performed hook");
                return {pl : r.pl, er: r.er};
            })
            .fail(null, function reject(r) {
                console.log("FAILED Photo Inspection Performed hook:", r);
                return {pl : null, er : "Unable to save inspection status:"+JSON.stringify(r)}
            });
    };
    var _completeLZS105 = function(){
        return Q().then(function(){console.log("ALL COMPLETED LZB105")})
    };


    //

    //LZB 106 - Photo Correction

    //
    var _scheduleLZS106 = function _schedulePhotoCorrectionHook(payload, user, responseObj, transactionid){
        var ac_code = exports.digFor(responseObj,"acn"),
            sv_code = exports.digFor(responseObj,"sb.0.svn"),
            responseObjectToReturn = {pl: null, er:null};
        return Q()
            .then(function getPhotoInfo(){
                var tgtURLS;
                if(responseObj && responseObj.fd && responseObj.fd.pt && responseObj.fd.pt[0] && responseObj.fd.pt[0].pp)
                    tgtURLS = responseObj.fd.pt[0].pp.urls
                return esbMessage({
                    "ns":"pmm",
                    "op":"pmm_getPhotoByUri",
                    "pl":{
                        ac: ac_code ,
                        uri: tgtURLS?tgtURLS.replace("_s",""):undefined,
                        loginName : user.lanzheng.loginName,
                        currentOrganization : user.currentOrganization
                        //sg: 10
                    }
                })
            })
            .then(function(photo){
                photo.pl.loginName = user.lanzheng.loginName;
                photo.pl.currentOrganization = user.currentOrganization;
                return esbMessage({
                    ns: 'pmm',
                    op: "pmm_SubmitPhotoToCorrection",
                    pl: photo.pl
                })
            })
            .then(function resolve(r){
                console.log("Handled Photo Correction successfully");
                return responseObjectToReturn;
            }  ,  function failure(r){
                console.log("Unable to issue (special case) order (rolling back):",r);
                return me.rollback({pl:{transactionid : transactionid.pl.transaction._id}});
            });
        };
    var _performLZS106 = function _performPhotoCorrectionHook(payload, user, responseObj, transactionid){
        console.log("in photocorrection hook",payload);
        var deferred = Q.defer();
        try {
                var fields = payload.formidableResults.fields;
                var files = payload.formidableResults.files;
                var err = payload.formidableResults.err;
                console.log("in parse with error =", err);
                if (err) {
                    deferred.resolve({
                        responsePayload:{
                            pl:{rs:false}
                        },
                        returnCode:200
                        /*
                        returnCode: 500,
                        errorCode: 1012,
                        errorMessage: err
                        */
                    });
                    return;
                }
                var old_path = files.file.path,
                    file_name = files.file.name,
                    jsonData = JSON.parse(fields.json);

                fs.readFile(old_path, function (err, data) {
                    console.log("reading file with error = ", err);
                    if (err) {
                        deferred.resolve({pl:false,er:err});
                        return;
                    }
                    payload.toSet.photoData = data;
                    payload.toSet.ifm = files.file.name.split('.').pop();
                    payload.toSet.pp.ofs = files.file.size;
                    payload.toSet.pp.isd = Date.now();
                    payload.toSet.uri = '/photos/' + jsonData.pl.photoname;
                    payload.toSet.loginName = user.lanzheng.loginName;
                    payload.toSet.currentOrganization = user.currentOrganization;
                    deferred.resolve(esbMessage({
                        ns: "pmm",
                        op: "pmm_setCorrectionPhotoAsDone",
                        pl: payload.toSet
                    })
                        .then(function (r) {

                            //throw {pl:null,er:{ec:58282, em:'TESTING ERROR ON PERFORM IN CORRECTION'}};
                            console.log(' pmh save corrected photo saved to bucket', r);

                            return esbMessage({
                                ns: 'bmm',
                                op: 'bmm_updateResponsePhotoByResponseCode',
                                pl: {
                                    rc: r.pl.rc,
                                    uri: r.pl.uri,
                                    urll: r.pl.urll,
                                    urlm: r.pl.urlm,
                                    urls: r.pl.urls,
                                    loginName : user.lanzheng.loginName,
                                    currentOrganization : user.currentOrganization
                                }
                            })
                        })
                        .then(function success(r) {
                            console.log(' pmh updated response photo successful--', r);
                            return {pl:true,er:null}

                        }, function failure(r) {
                            console.log(' pmh --error------ ', r);
                            //todo - (Ed) I found this returning 200(OK)... shouldn't it put up an error?
                            return {pl:false,er:r}
                        }));
                });
            //});
        }catch(e){
            console.log("FORM PARSE CATCHED:",e);
            deferred.resolve({pl:false,er:e})
        }
        return deferred.promise;
    };
    var _completeLZS106 = function(){
        return Q().then(function(){console.log("ALL COMPLETED LZB106")})
    };

    //

    //LZB 112 - Dummy Hook to Trigger Next

    //
    var _scheduleLZS112 = function _scheduleDummyHook(payload,user,responseObj,transactionid){

        return Q()
            //Update response Status
            .then(function (r) {
                return esbMessage({
                    "ns": "bmm",
                    "op": "bmm_persistResponse",
                    "pl": {
                        transactionid: transactionid,
                        loginName: user.lanzheng.loginName,
                        currentOrganization: user.currentOrganization,
                        response: {
                            _id: responseObj._id,
                            //rs: 45,
                            ow: responseObj.ow,
                            rfc: responseObj.rfc
                        }
                    }
                })
            })
            //Immediately schedule next service
            .then(function(r){
                return me.perform(responseObj.rc, "LZS112", {}, user, "DO_NEXT")
            })
            //EXIT
            .then(function resolve(r){
                responseObjectToReturn = {pl:r,er:null};
                return responseObjectToReturn;
            }  ,  function failure(r){
                console.log("Unable to issue (special case) order (rolling back):",r);
                return me.rollback({pl:{transactionid : transactionid.pl.transaction._id}});
            });
    }
    var _performLZS112 = function _performDummyHook(payload,user,responseObj,transactionid){
        return Q().then(function(){console.log("Perform stub for dummy"); return {pl:null, er:null};})
    }
    var _completeLZS112 = function(){
        return Q().then(function(){console.log("ALL COMPLETED LZS112")})
    }

    var specialCases =  [
        {ac:"LZB101",sv:"LZS101",onSchedule:_scheduleLZS101,onPerform:_performLZS101, onComplete:_completeLZS101},
        {ac:"LZB101",sv:"LZS107",onSchedule:_scheduleLZS101,onPerform:_performLZS101, onComplete:_completeLZS101},
        {ac:"LZB101",sv:"LZS108",onSchedule:_scheduleLZS101,onPerform:_performLZS101, onComplete:_completeLZS101},
        {ac:"LZB109",sv:"LZS112",onSchedule:_scheduleLZS112,onPerform:_performLZS112, onComplete:_completeLZS112},
        {ac:"LZB109",sv:"LZS109",onSchedule:_scheduleLZS101,onPerform:_performLZS101, onComplete:_completeLZS101},
        {ac:"LZB102",sv:"LZS102",onSchedule:_scheduleLZS102,onPerform:_performLZS102, onComplete:_completeLZS102},
        {ac:"LZB103",sv:"LZS103",onSchedule:_scheduleLZS103,onPerform:_performLZS103, onComplete:_completeLZS103},
        {ac:"LZB104",sv:"LZS104",onSchedule:_scheduleLZS104,onPerform:_performLZS104, onComplete:_completeLZS104},
        {ac:"LZB105",sv:"LZS105",onSchedule:_scheduleLZS105,onPerform:_performLZS105, onComplete:_completeLZS105},
        {ac:"LZB105",sv:"LZS106",onSchedule:_scheduleLZS106,onPerform:_performLZS106, onComplete:_completeLZS106}
    ];

    this.cases = specialCases;
    me.schedule = triggerFn;
    me.perform = performFn;
    me.rollback = rollbackFn;
    me.commit = commitFn;
}

