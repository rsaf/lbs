/* 
 * This should be a seperate project that other modules can depend on (see the Transaction model in models as well)
 * Code here will help the module to start, commit and roll back transactions
 */

var utils = require('./lib.js');

var q = require('q');
var TransactionHelper = function(mongoose,transactionSchema,transaction){
  this.mongoose = mongoose;
  this.TransactionSchema=transactionSchema;
  this.Transaction = transaction;
};
TransactionHelper.prototype = {
  constructor:TransactionHelper
  , isValidObjectId:function isValidObjectId(id){
    if(id&&id.toString){
      id=id.toString();
    }
    /*jshint ignore:start*/
    if(id == null) return false;
    if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24)) {
      return false;
    } else {
    // Check specifically for hex correctness
    if(typeof id == 'string' && id.length == 24) return /^[0-9a-fA-F]{24}$/.test(id);
      return false;
    }
    /*jshint ignore:end*/
  }
  , prepareCreate:function prepareCreate(m){
    var me=this;
    return q()
    .then(function(){
      m = m || {};
      if(!m.collectionName){
        return q.reject('Missing Entity name property for prepareCreate.');
      }
      if(!(me.mongoose.models[m.collectionName] && typeof me.mongoose.models[m.collectionName].remove==='function')){
        return q.reject('In prepareCreate: Model with entity name:'+m.collectionName+' does not have a remove function, cannot remove as rollback.');
      }
      if(!(m.entity && m.entity._id)){
        return q.reject('In prepareCreate: preparing to insert but no _id was provided. Use me.mongoose.Types.ObjectId() to create an _id first.');
      }
      if(!me.isValidObjectId(m.transactionid.toString())){
        return q.reject('In prepareCreate: preparing to insert but no valid transaction id was provided.');
      }
      return me.Transaction.create({status:'prepare'
        ,transactionid:m.transactionid
        ,entityid:m.entity._id
        ,operation:'create'
        ,collectionName:m.collectionName}
      );
    })//me.mongoose promises do not have .then or .catch return a q promise
    .then(function resolvePrepare(trans) {
      return q.resolve(trans);
    },function rejectPrepare(err) {
      return q.reject('Error in prepareCreate'+err.message);
    });
  }
  , prepareUpdate:function prepareUpdate(m){
    var me = this;
    return q()
    .then(function(){
      m = m || {};
      if(!m.collectionName){
        return q.reject('Missing Entity name property for prepareUpdate.');
      }
      if(!(me.mongoose.models[m.collectionName] && typeof me.mongoose.models[m.collectionName].collection.save==='function')){
        return q.reject('In prepareUpdate: Model with entity name:'+m.collectionName+' does not have a save function, cannot save as rollback.');
      }
      if(!(m.entity && m.entity._id)){
        return q.reject('In prepareUpdate: preparing to update but entity has no _id.');
      }
      if(!me.isValidObjectId(m.transactionid.toString())){
        return q.reject('In prepareUpdate: preparing to update but transaction has no valid _id.');
      }
      if(Object.keys(m.entity).length===1){
        return me.mongoose.models[m.collectionName].findOne({_id:m.entity._id.toString()},function(){}).exec();
      }
      return q.resolve(m.entity);
    }).then(function(entity){
      return me.Transaction.create({
        status:'prepare'
        ,transactionid:m.transactionid
        ,orgValue:entity
        ,entityid:entity._id
        ,operation:'update'
        ,collectionName:m.collectionName}
      );
    })//me.mongoose promises do not have .fail or .catch, return a q promise
    .then(function resolvePrepare(trans) {
      return q.resolve(trans);
    },function rejectPrepare(err) {
      return q.reject('Error in prepareUpdate:'+err.message+" - ");
    });
  }
  , prepareDelete:function prepareDelete(m){
    var me = this;
    return q()
    .then(function(){
      m = m || {};
      if(!m.collectionName){
        return q.reject('Missing Entity name property for prepareDelete.');
      }
      if(!(me.mongoose.models[m.collectionName] && typeof me.mongoose.models[m.collectionName].create==='function')){
        return q.reject('In prepareDelete: Model with entity name:'+m.collectionName+' does not have a create function, cannot create as rollback.');
      }
      if(!(m.entity && m.entity._id)){
        return q.reject('In prepareDelete: preparing to delete but no _id was provided.');
      }
      if(!me.isValidObjectId(m.transactionid.toString())){
        return q.reject('In prepareDelete: preparing to delete but no valid transaction id was provided.');
      }
      //find the entity if it only has an _id
      if(Object.keys(m.entity).length===1){
        return me.mongoose.models[m.collectionName].findOne({_id:m.entity._id.toString()},function(){})
                .exec();
      }
      return q.resolve(m.entity);
    }).then(function(entity){
      return me.Transaction.create({status:'prepare'
        ,transactionid:m.transactionid
        ,orgValue:entity
        ,entityid:m.entity._id
        ,operation:'delete'
        ,collectionName:m.collectionName}
      );
    })//me.mongoose promises do not have .fail or .catch, return a q promise
    .then(function resolvePrepare(trans) {
      return q.resolve(trans);
    },function rejectPrepare(err) {
      return q.reject('Error in prepareDelete:'+err.message+" - ");
    });
  }
  /**
   * 
   * @param m {Object} information needed to prepare a multiple update
   * @param m.collectionName The name of the collection involved (for example services, requests, logs ...
   * @param m.transactionid Valid object id (can be string) containing the id of the transaction (should have been given by the handler using wmm)
   * @param m.query query that was used to update the items (for example {service_id:'000000000000000001010101'}
   * @param m.values The original values, for example; when updating service_name {service_name:'old name'},{$set:{'service_name':'new name'} then values should be {'service_name':'old name'}
   */
  , prepareMultiUpdate:function prepareUpdate(m){
    var me = this;
    return q()
    .then(function(){
      m = m || {};
      if(!m.collectionName){
        return q.reject('Missing Entity name property for prepareUpdate.');
      }
      if(!(me.mongoose.models[m.collectionName] && typeof me.mongoose.models[m.collectionName].collection.update==='function')){
        return q.reject('In prepareMultipleUpdate: Model with entity name:'+m.collectionName+' does not have a update function, cannot save as rollback.');
      }
      m.entity={_id:'000000000000000000008888'};
      if(!me.isValidObjectId(m.transactionid.toString())){
        return q.reject('In prepareMultiUpdate: preparing to update but transaction has no valid _id.');
      }
      return me.Transaction.create({
        status:'prepare'
        ,transactionid:m.transactionid
        ,orgValue:m.entity
        ,entityid:m.entity._id
        ,operation:'multi-update'
        ,collectionName:m.collectionName
        ,query:m.query
        ,values:m.values        
      }
      );
    })//me.mongoose promises do not have .fail or .catch, return a q promise
    .then(function resolvePrepare(trans) {
      return q.resolve(trans);
    },function rejectPrepare(err) {
      return q.reject('Error in prepareMultiUpdate'+err.message);
    });
  }
  , commit:function commit(m){
    var me = this;
    return q()
    .then(function(){
      return me._updateTransactions({
        doc:{ status: 'commited' }
        ,query:{"transactionid":m.transactionid}
      })//me.mongoose promises do not have .fail or .catch, return a q promise
      .then(function resolveCommit(ret) {
        return q.resolve(ret);
      },function rejectCommit(err) {
        return q.reject(err);
      });      
    });
  }
  , rollback:function rollback(m){
    var me = this;
    return q().then(function(){
      if(!me.isValidObjectId(m.transactionid.toString())){
        return q.reject('In rollback: preparing to rollback but no valid transaction id was provided.');
      }
      //get transactions for multi-update
      return me.Transaction.find({"transactionid":m.transactionid,operation:{$in:['multi-update']}},function(){})
          .select({query:1,values:1,collectionName:1})
          .exec();
    }).then(function(transactions){
      return q.all([
        me._rollbackByquery({transactions:transactions})
        ,me.Transaction.find({"transactionid":m.transactionid,operation:{$in:['create']}},function(){})
          .select({entityid:1,collectionName:1})
          .exec()]);
    }).then(function(transactions){
      return me._deleteOriginals({transactions:transactions[1]});
    }).then(function(){
      return me.Transaction.find({"transactionid":m.transactionid,operation:{$in:['delete','update']}},function(){})
          .select({entityid:1,orgValue:1,operation:1,collectionName:1})
          .sort({_id:1})
          .exec();
    }).then(function(transactions){
      return me._restoreOriginals({transactions:transactions});
    }).then(function(){
      return me._updateTransactions({
        doc:{ status: 'rolledback' }
        ,query:{"transactionid":m.transactionid.toString()}
      });
    })//me.mongoose promises do not have .fail or .catch, return a q promise
    .then(function resolveRollback(res) {
      return q.resolve(res);
    },function rejectRollback(err) {
      return q.reject(err);
    });
  }
  , getNextSequence: function getNextSequence(name){
    var me = this;
    return q()
    .then(function(){//wrap as a promise to make sure it'll return a promise even when throwing
      var d = q.defer();
      me.mongoose.models['counters'].findOneAndUpdate({_id:name},{ $inc: { seq: 1 } },function(e,dt){
        if(e){
          d.reject(e);return;
        }
        d.resolve(dt);
      });
      return d.promise;      
    });
  }
  , getCreate: function getCreate(collectionName,entity,transactionid,query,okCreate,credential){
    var ret=false;
    var me = this;
    return q()
    .then(function(){

      if(me.isValidObjectId(entity._id)&&!query){
        ret = me.mongoose.models[collectionName].findOne({_id:entity._id}).exec();
      }else if(query){
        ret = me.mongoose.models[collectionName].findOne(query).exec();
      }else{
          var result = new me.mongoose.models[collectionName]();
          if(result.s && credential)
          {
              result.s.own.uid = credential.user;
              result.s.grp.uid = credential.organization;
          }
          ret = q(result);
      }
      return ret;
    })
    .then(function(result){
        var transParams={};
        var preparefn='';
        if(!result){
          if(query&&okCreate){
            result = new me.mongoose.models[collectionName]();
              if(result.s && credential)
              {
                  result.s.own.uid = credential.user;
                  result.s.grp.uid = credential.organization;
              }
          }else{
            return q.reject('cannot find the entity in '+collectionName);            
          }
        }
        ret = result;
        if(transactionid){
          transParams={
            transactionid:transactionid
            ,entity:result
            ,collectionName:collectionName
          };
          preparefn=result.isNew?'prepareCreate':'prepareUpdate';
          return me[preparefn](transParams);
        }
        return true;
      })
    .then(
      function resolve(){
        return q.resolve(ret);
      },function reject(err){
        return q.reject("In lib transactonHelper getCreate; "  + err);
      }
    );
    
    
  }
  /**
   * Sets the dbEntity with fields of uiEntity if these fields are part of the 
   * schema (mongoose.models[collectionName].schema.paths) where collectionName
   * is the name passed to the function (for example 'services')
   * loginUser and currentOrganization are set (if defined) in created and last updated
   * callback: this is an object that contains keys with a function for it's value 
   *   for example {name:function(){}}
   *   if uiEntity.name is set then before setting the name for dbEntity it will
   *   invoke the function, when this function returnes false then 
   *   the value dbEntity.name will not be set (your funtion may have done so already)
   *   This could be handy when trying to change an item in an array
   * @param {Object} dbEntity
   * @param {Object} uiEntity
   * @param {String} collectionName
   * @param {String} loginUser
   * @param {String} currentOrganization
   * @param {Object} callback
   * @returns {undefined}
   */
  , setFields: function setFields(dbEntity,uiEntity,collectionName,loginUser,currentOrganization,callback){
    callback=callback||{};
    var keys = Object.keys(this.mongoose.models[collectionName].schema.paths);
    var i=keys.length,val,objToSet,keyArray;
    if(dbEntity.isNew){
      this.setCreated({entity:uiEntity,loginName:loginUser,currentOrganization:currentOrganization});
    }
    this.setLastUpdated({entity:uiEntity,loginName:loginUser,currentOrganization:currentOrganization});
    while((i-=1)>-1){
      keyArray=keys[i].split(".");
      val =  utils.getMember(uiEntity,keyArray);
      if(val!==undefined){
        if(typeof callback[keys[i]]==='function'){
          if(!callback[keys[i]](dbEntity,uiEntity,keys[i])){
            continue;
          }
        }
        objToSet=utils.getMember(dbEntity,keyArray.slice(0,-1));
        objToSet[keyArray.slice(-1)]=val;
      }
    }
  }
  ,setLastUpdated : function setLastUpdated(arg){
    arg.entity.md = arg.entity.md || {};
    if(arg.loginName){
      arg.entity.md.uID=arg.loginName;
    }
    if(arg.currentOrganization){
      arg.entity.md.oID=arg.currentOrganization;
    }
    arg.entity.md.lu=new Date();
  }
  ,setCreated : function setCreated(arg){
    arg.entity.ct = arg.entity.ct || {};
    if(arg.loginName){
      arg.entity.ct.uID=arg.loginName;
    }
    if(arg.currentOrganization){
      arg.entity.ct.oID=arg.currentOrganization;
    }
    arg.entity.ct.lu=new Date();
  }
  ,saveToPromise : function saveToPromise(document){
    return q()
    .then(function(){
      var d = q.defer();
      document.save(function(paramError,paramData){
        if(paramError){
            console.log("Unsaved document:\n",document);
          d.reject(paramError);return;
        }
        d.resolve(paramData);
      });
      return d.promise;
    })
    .then(null,function reject(err){
      return q.reject('In saveToPromise:'+err+' ');
    });
  }

  ,_rollbackByquery:function _rollbackByquery(arg){
    var me = this;
    var transactions=arg.transactions,i = transactions.length,promises=[];
    while((i-=1)>-1){
      promises.push(
        me.mongoose.models[transactions[i].collectionName].update(
          transactions[i].query
          ,{$set:JSON.parse(transactions[i].values)}
          ,{multi:true}).exec()
      );
    }
    return q.all(promises);
  }
  ,_updateTransactions:function _updateTransactions(arg){
    
    return this.Transaction.update(arg.query,arg.doc,{multi:true})
      .exec(function(){});//add dummy function to force it to write as save    
  }
  ,_insertOriginals:function _insertOriginals(arg){
    var me = this;
    var i=arg.transactions.length,promises=[];
    function addPromise(t){
      return me.mongoose.models[t.collectionName].create(t.orgValue,function(e,d){});
    }
    while((i-=1)>-1){
      promises.push(addPromise(arg.transactions[i]));
    }
    return q.all(promises)
    .then(function resolve(res){//this.mongoose promise has no .then or .catch, return a q promise
      return q.resolve(res);
    },function reject(err){
      return q.reject(err);
    });
  }
  ,_deleteOriginals : function _deleteOriginals(arg){
    var me = this;
    return q()
    .then(function(){
      var i=arg.transactions.length,cols={},promises=[],collectionName,
              prop=Object.hasOwnProperty;
      //group by collection name
      while((i-=1)>-1){
        cols[arg.transactions[i].collectionName]=cols[arg.transactions[i].collectionName]||[];
        cols[arg.transactions[i].collectionName].push(arg.transactions[i].entityid);
      }
      for(collectionName in cols){
        if(prop.call(cols,collectionName)){
          promises.push(
            me.mongoose.models[collectionName].remove({_id:{"$in":cols[collectionName]}}).exec()
          );
        }
      }
      return q.all(promises)
      .then(function resolve(res){//me.mongoose promise has no .then or .catch, return a q promise
        return q.resolve(res);
      },function reject(err){
        return q.reject(err);
      });
    });
  }
  ,_restoreOriginals:function _restoreOriginals(arg){
    var me = this;
    var i=arg.transactions.length,promises=[];
    function deleteInsert(t){
      return me._deleteOriginals({transactions:[t]})
      .then(function(){
        return me._insertOriginals({transactions:[t]});
      });
    }
    while((i-=1)>-1){
      promises.push(deleteInsert(arg.transactions[i]));
    }
    return q.all(promises)
    .then(function resolve(res){//me.mongoose promise has no .then or .catch, return a q promise
      return q.resolve(res);
    },function reject(err){
      return q.reject(err);
    });
  }
};


//
//inject all dependencies
exports.init = function init(m) {
  var mongoose = m.pl.mongoose;
  var TransactionSchema = require("./models/Transaction.js")(mongoose);
  var Transaction = mongoose.model('transactions', TransactionSchema);
  return new TransactionHelper(mongoose,TransactionSchema,Transaction);
};


