/*
 * Tests for ../smm_interface
 */



var helper = require('./fixtures/helper.js')
  ,deferMock
  ,qMock
  ,plMock
  ,mongooseMock
  ,serviceSchemaMock
  ,smm;

exports.setUp=function setUp(callback){
  deferMock = new helper.unit.MockBase({
    fns:[
        {fnName:'reject'}
       ,{fnName:'resolve'}
    ]
  });
  deferMock.promise=8131832915823907;
  qMock = new helper.unit.MockBase({
    fns:[
       {fnName:'resolve'}
      ,{fnName:'all',retVal:'return of Q.all'}
      ,{fnName:'defer',retVal:deferMock}
    ]
  });
  //add qmock instance itself to return value for a function
  //  cannot pass it to the constructor because the instance
  //  doesn't exist yet until the constructor is done
  qMock.addFn({fnName:'then',retVal:qMock});
  qMock.addFn({fnName:'fail',retVal:qMock});
  qMock.addFn({fnName:'fcall',retVal:qMock});
  
  smm = helper.unit.getModule({
    path:'../../smm_Interface.js'
    ,mocks:{ 'q': qMock }
  });
  helper.functionsOnObject(smm);
  plMock = new helper.unit.MockBase({
    fns:[{fnName:'fn',retVal:qMock}]  
  });
  serviceSchemaMock = new helper.unit.MockBase({
    fns:[
       {fnName:'create'}
      ,{fnName:'servicesByCreator',retVal:qMock}
    ]
  });
  serviceSchemaMock.statics={};
  mongooseMock = new helper.unit.MockBase({
    fns:[
       {
         fnName:'model'//when modal is called return contidional return
            //condition based on parameters
         ,conditionalReturn:helper.unit.MockBase.PARAM_CONDITION
         ,condition:[
            {param:['services'],ret:serviceSchemaMock}//if 1st parameter is 'services' then return 'service schema'
           ,{param:['businesses'],ret:'business schema'}//if 1st parameter is 'businesses' then return 'business schema'
         ]
        }
      ,{fnName:'Schema',retVal:serviceSchemaMock}
    ]
  });
  mongooseMock.Schema.Types={
    ObjectId:22
  };
  mongooseMock.version = 'Mock Mongoose';
  mongooseMock.connection = {
    name:'mocked connection'
  };
  callback();
};

exports.tearDown=function tearDown(callback){
  callback();
};



exports.testInit = function(test){
  test.expect(7);
  var ret;
  smm.init({pl:plMock,ns:0.5401284771505743});
  qMock.uniqueVal = 0.7723746916744858;
  test.strictEqual(qMock.fnCalled.fcall.length,1
    ,'Call Q.fcall to wrap all code in a returnable promise.');
  test.strictEqual(qMock.fnCalled.then.length,1
    ,'Call then on the promise.');
  test.strictEqual(qMock.fnCalled.fail.length,1
    ,'Call Q.fail to catch any errors and return a message.');
  test.strictEqual(qMock.fnCalled.fcall[0].arguments[0]().uniqueVal,0.7723746916744858
    ,'When Q.fcall is invoked return the result of m.pl.fn.');
  test.strictEqual(qMock.fnCalled.then[0].arguments[0]({pl:{fn:mongooseMock}}).pl.pm,'smm initialization done!'
    ,'When promise.then is invoked return a message.');
  ret = qMock.fnCalled.fail[0].arguments[0]('an error');
  test.strictEqual(ret.pl,null
    ,'When fail is called return the correct message, payload should be null.');
  test.strictEqual(ret.er.ec>1000,true
    ,'When fail is called return the correct message, er.ec should be greater than 1000.');
  test.done();
};

exports.testCreateService = function testCreateService(test){
  test.expect(11);
  var ret;
  smm.init({pl:plMock,ns:0.5401284771505743});//init the module with mocks
  qMock.fnCalled.then[0].arguments[0]({pl:{fn:mongooseMock}});
  qMock.resetFnCalled();
  smm.createService({pl:{userid:0.6563578168861568,}});
  test.strictEqual(qMock.fnCalled.fcall.length,1//also from init
    ,'Call Q.fcall to wrap all code in a returnable promise.');
  test.strictEqual(qMock.fnCalled.fail.length,1//also form init
    ,'Call Q.fail to catch any errors and return a message.');
  test.strictEqual(qMock.fnCalled.fcall[0].arguments[0](),8131832915823907
    ,'When Q.fcall is invoked return the result of m.pl.fn.');
  //@todo: check values passed to service.create
  console.log('@todo:check values passed to service.create',serviceSchemaMock.fnCalled.create[0].arguments[0]);
  //mongoose comes back with an error
  serviceSchemaMock.fnCalled.create[0].arguments[1]('the error');
  ret = deferMock.fnCalled.reject[0].arguments[0]
  test.strictEqual(ret.pl,null
    ,'When mongodb calls back with an error, call defer.reject with a message having null payload.');
  test.strictEqual(ret.er.ec>1000,true
    ,'When mongodb calls back with an error, call defer.reject with a message er.ec greater than 1000.');
  test.strictEqual(ret.er.em,'the error'
    ,'When mongodb calls back with an error, call defer.reject with a message er.em given by mongoose.');
  try{
    qMock.fnCalled.fail[0].arguments[0](new Error('the error'));
  }catch(e){
    test.strictEqual(e.pl,null
      ,'Fail with a thrown error re throws in fail with a message having null payload.');
    test.strictEqual(e.er.ec>1000,true
      ,'Fail with a thrown error re throws in fail  with a message er.ec greater than 1000.');
    test.strictEqual(e.er.em,'the error'
      ,'Fail with a thrown error re throws in fail  with a message er.em given by mongoose.');
  }
  try{
    qMock.fnCalled.fail[0].arguments[0]({er:{ec:1001,em:'mongooseerror'}});
  }catch(e){
    test.strictEqual(e.er.ec>1000,true
      ,'Fail with a reject promise message re throws in fail with the message er.ec greater than 1000.');
    test.strictEqual(e.er.em,'mongooseerror'
      ,'Fail with a reject promise message re throws in fail with the message er.em given by mongoose.');
  }
  test.done();
};

exports.testServicesByCreator = function testServicesByCreator(test){
  test.expect(11);
  var ret;
  smm.init({pl:plMock,ns:0.5401284771505743});//init the module with mocks
  qMock.fnCalled.then[0].arguments[0]({pl:{fn:mongooseMock}});
  qMock.resetFnCalled();
  smm.servicesByCreator({pl:{userAccountID:0.6563578168861568}});
  test.strictEqual(qMock.fnCalled.fcall.length,1//also from init
    ,'Call Q.fcall to wrap all code in a returnable promise.');
  test.strictEqual(qMock.fnCalled.fail.length,1//also form init
    ,'Call Q.fail to catch any errors and return a message.');
  test.strictEqual(qMock.fnCalled.fcall[0].arguments[0](),8131832915823907
    ,'When Q.fcall is invoked return the result of m.pl.fn.');
  //mongoose comes back with an error
  serviceSchemaMock.fnCalled.servicesByCreator[0].arguments[1]('the error');
  ret = deferMock.fnCalled.reject[0].arguments[0]
  test.strictEqual(ret.pl,null
    ,'When mongodb calls back with an error, call defer.reject with a message having null payload.');
  test.strictEqual(ret.er.ec>1000,true
    ,'When mongodb calls back with an error, call defer.reject with a message er.ec greater than 1000.');
  test.strictEqual(ret.er.em,'the error'
    ,'When mongodb calls back with an error, call defer.reject with a message er.em given by mongoose.');
  try{
    qMock.fnCalled.fail[0].arguments[0](new Error('the error'));
  }catch(e){
    test.strictEqual(e.pl,null
      ,'Fail with a thrown error re throws in fail with a message having null payload.');
    test.strictEqual(e.er.ec>1000,true
      ,'Fail with a thrown error re throws in fail  with a message er.ec greater than 1000.');
    test.strictEqual(e.er.em,'the error'
      ,'Fail with a thrown error re throws in fail  with a message er.em given by mongoose.');
  }
  try{
    qMock.fnCalled.fail[0].arguments[0]({er:{ec:1001,em:'mongooseerror'}});
  }catch(e){
    test.strictEqual(e.er.ec>1000,true
      ,'Fail with a reject promise message re throws in fail with the message er.ec greater than 1000.');
    test.strictEqual(e.er.em,'mongooseerror'
      ,'Fail with a reject promise message re throws in fail with the message er.em given by mongoose.');
  }
  test.done();
};