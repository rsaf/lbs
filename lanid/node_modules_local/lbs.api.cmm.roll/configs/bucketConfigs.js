/**
 * Created by LBS006 on 1/23/15.
 */

var uuid = require('node-uuid');
var Connection = require('ssh2');
var Q = require('q');
var fs = require('fs-extra');

if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(searchString, position) {
    position = position || 0;
    return this.lastIndexOf(searchString, position) === position;
  };
}

function get_bucket_server(uuid) {
    var bucket1_pattern = /^[0-9][0-9a-f]{7}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/;
    var bucket2_pattern = /^[a-f][0-9a-f]{7}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/;
    var bucket = null;
    if (bucket1_pattern.test(uuid)){
        bucket = require('./configs.json').bkconfig.bucket1;
        console.log('returning bucket1', bucket, uuid );
        return bucket;
    }
    else if (bucket2_pattern.test(uuid)){
       bucket = require('./configs.json').bkconfig.bucket2;
        console.log('returning bucket2', bucket, uuid );
        return bucket;
    } else {
       throw new Error('Invalid UUID: ' + uuid);
    }
}

function get_private_key() {
    return (process.env['HOME'] + require('./configs.json').bkconfig.privatekey);
}

module.exports.getBucketServers = function (){
    return get_bucket_server;
}

module.exports.getBucketManager = function (){
    return function executeBucketCommand(paramCommand, paramUUID, paramExtension, paramFileData, paramOptions) {
        console.log('\nIn function executeBucketCommand.... ');
        //only needed when uploading an image
        var varPHOTO_FORMAT = null;
        var varPHOTO_DIMEMSION = null;
        var varPHOTO_SIZE = null;
        var destination_file_uuid = null;
        var destination_bucket_server = null;
        var command = null;
        var r = {"pl": {uuid:null}, "er": null};
        var deferred = Q.defer();
        var file_uuid = paramUUID;

        if (!file_uuid){
             file_uuid = uuid.v4();
        }

        var server = get_bucket_server(file_uuid);

        if(paramCommand=="copyphoto"){
            destination_file_uuid = uuid.v4();
            destination_bucket_server = get_bucket_server(destination_file_uuid);
            //paramOptions = destination_file_uuid + " " + destination_bucket_server + " " + paramOptions;
            paramOptions = destination_bucket_server + " " + destination_file_uuid ;

        }

        command=paramCommand + " " + file_uuid + " " + paramExtension + " " + paramOptions;

        console.log('Will be uploading data with uuid:' + file_uuid);
        console.log('Will be executing command:' + command);
        console.log('Will be connecting to bucket:' + server);


        var conn = new Connection();

        var privateKeyFilename = get_private_key();
        var privateKey = fs.readFileSync(privateKeyFilename);

        var capturingBinary = false;
        var mapFilenameToUuid = {};
        var xlsxUuid = null;
        var xlsxData;
        var photoData;
        var totalBytes = 0;
        var binaryDataSize = 0;
        var tempPhotoData  = [];

        conn
            .on('connect', function(){
                console.log('ssh connected successfully to ' + server );
            })
            .on('ready', function () {
                console.log('Connection :: ready');
                conn
                    .exec(command, function (err, stream) {
                        if (err) return deferred.reject();
                        stream
                            .on('exit', function (code, signal) {
                                console.log('Stream :: exit :: code: ' + code + ', signal: ' + signal);

                                if (code === 0) {
                                    r.pl.uuid = file_uuid;
                                    //console.log('replying ', r);
                                   if(paramCommand === "unzipper") {
                                        console.log('total bytes ' + totalBytes);
                                        r.pl.xlsx = {
                                            uuid: xlsxUuid,
                                            data: xlsxData
                                        }
                                        r.pl.map = mapFilenameToUuid;
                                        console.log('FINAL REPLY FROM UNZIPPER', r);
                                        // TODO: remove, for testing only
                                       // fs.writeFileSync('/tmp/data.xlsx', xlsxData.slice(0, totalBytes));
                                       deferred.resolve(r);
                                    }
                                   else if (paramCommand === "copyphoto"){
                                        r.pl.uuid = destination_file_uuid;
                                       deferred.resolve(r);
                                    }
                                   else if (paramCommand === "loadphoto"){
                                      var bufferData= null;
                                      var sData = null;
                                      // console.log("THE LENGTH OF THE BUFFER ARRAY", tempPhotoData.length);

                                      for (i=0; i< tempPhotoData.length; i++) {
                                         // console.log("BUFFER BLOCK INDEX ", i);
                                          bufferData = tempPhotoData[i];
                                         // console.log("BUFFER BLOCK LENGTH ", bufferData.length);


                                          if(capturingBinary) {
                                             // console.log("TOTAL SIZE OF BUFFER TO CAPTURE", binaryDataSize);
                                             // console.log("SIZE OF BUFFER CAPTURED", totalBytes);
                                            //  console.log('SIZE BUFFER LEFT TO CAPTURE,',binaryDataSize - totalBytes);
                                              bufferData.copy(photoData, totalBytes, 0, binaryDataSize - totalBytes);
                                              totalBytes += bufferData.length;
                                            //  console.log("SIZE OF BUFFER NOW CAPTURED", totalBytes);
                                             // console.log('SIZE BUFFER NOW LEFT TO CAPTURE,',binaryDataSize - totalBytes);

                                              if(binaryDataSize <= totalBytes) {
                                                  capturingBinary = false;
                                                  r.pl.photoData = photoData;
                                                  r.pl.photoSize = binaryDataSize;
                                                  console.log('ENDING CAPTURE DATA ...');
                                              }
                                          } else {
                                              sData = bufferData.toString();
                                              sData.split('\n').forEach(function(line) {
                                                  if(line.startsWith('DATA PHOTO START')) {
                                                      binaryDataSize = parseInt(sData.slice('DATA PHOTO START'.length));
                                                      console.log('STARTING CAPTURE DATA ...');
                                                      console.log('TARGET TOTAL BYTES ' + binaryDataSize);
                                                      photoData = new Buffer(binaryDataSize);
                                                      capturingBinary = true;
                                                  }
                                              });
                                          }
                                      }
                                       console.log('TOTAL BYTES SENT ' + binaryDataSize);
                                       if(photoData)
                                       console.log('TOTAL BYTES RECEIVED ' + photoData.length);
                                       else console.log("PHOTO DATA WAS OF SIZE ZERO");
                                       deferred.resolve(r);

                                   }
                                   else {
                                       deferred.resolve(r);
                                   }

                                } else {
                                    deferred.reject(new Error('Connection to ' + server + ' exitcode ' + code));
                                }
                            })
                            .on('close', function () {
                                console.log('Stream :: close');
                                conn.end();

                            })
                            .on('data', function (data) {
                                console.log('IN ON DATA OF SSH ...');
                                console.log('STDOUT: ' + data);
                                if(paramCommand === "uploadphoto"){
                                    var dataString = data.toString().split(" ");
                                    if((dataString.length ===6) && dataString[0]==='PHOTO_FORMAT'){
                                        varPHOTO_FORMAT = dataString[1];
                                        varPHOTO_DIMEMSION = dataString[3];
                                        varPHOTO_SIZE = dataString[5];
                                        r.pl = {uuid:null, pfm:null, pd:null, ps:null};
                                        r.pl.pfm = varPHOTO_FORMAT;
                                        r.pl.pd = varPHOTO_DIMEMSION;
                                        r.pl.ps = varPHOTO_SIZE;
                                    }
                                }
                                else if (paramCommand === "unzipper"){
                                    if(capturingBinary) {
                                        console.log('CAPTURING!');
                                        data.copy(xlsxData, totalBytes, 0, binaryDataSize - totalBytes);
                                        totalBytes += data.length;
                                        if(binaryDataSize >= totalBytes) {
                                            capturingBinary = false; 
                                        }
                                    } else {
                                        data.toString().split('\n').forEach(function(line) {
                                            if(line.startsWith('[MAP]')) {
                                                // $FILENAME=$CREATED_UUID
                                                filename = line.slice('[MAP]'.length, line.lastIndexOf('='));
                                                created_uuid = line.slice('[MAP]'.length + filename.length + 1, line.length);
                                                mapFilenameToUuid[filename] = created_uuid;
                                            } else if(line.startsWith('XLSX')) {
                                                // XLSX=$CREATED_UUID
                                                xlsxUuid = line.slice('XLSX='.length, line.length-1);
                                            } else if(line.startsWith('DATA XLSX START')) {
                                                binaryDataSize = parseInt(line.slice('DATA XLSX START'.length));
                                                console.log('target bytes ' + binaryDataSize);
                                                xlsxData = new Buffer(binaryDataSize);
                                                capturingBinary = true;
                                            }
                                        });
                                    }
                                }
                                else if (paramCommand === "loadphoto"){
                                    tempPhotoData.push(data);
                                }
                            })
                            .stderr.on('data', function (data) {
                                console.log('In STDERR: ' + data);
                            });
                        stream.end(paramFileData);
                    })
            })
            .connect({
                host: server,
                port: 22,
                username: 'uploadbot',
                privateKey: privateKey
            });

        return deferred.promise;
    }

}
