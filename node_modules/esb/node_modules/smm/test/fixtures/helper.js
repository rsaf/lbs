var proxyquire = require('proxyquire');
var Q = require('Q');

exports.functionsOnObject = function functionsOnObject(obj){
  var i,len,fnName;
  if(obj && obj.operations){
    i=-1;len=obj.operations.length;
    while(++i<len){
      if(typeof obj.operations[i]==='function'){
        fnName = obj.operations[i].toString().split(/[^a-z]/i)[1];
        obj[fnName]=obj.operations[i];
      }
    }
  }
};
exports.integration = {
  getModule:function(arg){
    arg=arg || {};//default get cmm
    var mod = require(arg.moduleName||'cmm');
    return {
       mod:mod
      ,promise:mod.init(arg.message||{pl:function(){}})
    };
  }
  ,getModules:function(arg){
    var moduleNames=arg.moduleNames || 
            (function(){
              throw new Error('Need to pass arg.moduleNames as array of strings.');
            }()),
    messages=arg.messages ||
            (function(){
              throw new Error('Need to pass arg.messages as array of objects.');
            }()),
    len = (moduleNames.length===messages.length)?moduleNames.length :
            (function(){
              throw new Error('arg.moduleNames and arg.messages need to be arrays with the same lenght.');
            }()),
    mods = [],
    deferred=Q.defer(),
    i=-1,
    mod,
    promises = [];
    while(++i<len){
      mod = this.getModule({moduleName:moduleNames[i],message:messages[i]});
      promises.push(mod.promise);
      mods.push(mod.mod);
    }
    Q.all(promises).then(function(){
      var i = -1,len=mods.length;
      while(++i<len){
        exports.functionsOnObject(mods[i]);
      }
      deferred.resolve(mods);
    },function(reason){console.log('rejected:',reason);}).fail(function(f){console.log('failed:',f)});
    return deferred.promise;
  }
};

exports.unit = {
  getModule:function(arg){
    var path=arg.path || 
            (function(){
              throw new Error('Need to pass arg.path as strings.');
            }());
    var mocks=arg.mocks;
    mocks['@noCallThru']= true;
    var mod = proxyquire(path,mocks);
    return mod;
  }
  ,MockBase:(function(){
    var MockBase = function MockBase(arg){
      arg = arg || {};
      var fns=arg.fns||[]
      ,i=-1,len=fns.length;
      while(++i<len){
        this.addFn(fns[i]);
      }
      this.fnCalled={};
    };
    MockBase.PARAM_CONDITION=1;
    MockBase.PARAM_SKIP='1-1-1-1-1SKIP0-0-0-0-0-0-unique value to indicate skip';
    MockBase.prototype.addFn=function addFn(arg){
      arg=arg||{};
      var fnName=arg.fnName ||(function(){
        throw new Error('Have to provide a fnName when creating a mock.');
      }());
      arg.mock=this;
      var mockCall=new this.MockCall(arg);
      this[fnName]=mockCall.createFn();      
    };
    MockBase.prototype.resetFnCalled=function(){
      this.fnCalled={};
    },
    MockBase.prototype.MockCall=function MockCall(arg){
      arg=arg||{};
      this.params=arg.params||{};
      this.retVal=arg.retVal||{};
      this.fnName=arg.fnName;
      this.mock=arg.mock;//sets the MockBase instance
      this.conditionalReturn=arg.conditionalReturn;
      this.condition=arg.condition;
    };
    MockBase.prototype.MockCall.prototype.returnParamConditional=function(args){
      var i=-1,j,conditionsLen=this.condition.length
        ,paramLen,pass=true,ret;
      while(++i<conditionsLen){
        pass=true;
        j=-1,paramLen=this.condition[i].param.length;
        while(++j<paramLen){
          if(this.condition[i].param[j]===MockBase.PARAM_SKIP){
            continue;
          }
          if(this.condition[i].param[j]!==args[j]){
            pass=false;
            break;
          }
        }
        if(pass){
          return {pass:true,ret:this.condition[i].ret};
        }
      }
      return {pass:false};
    };
    MockBase.prototype.MockCall.prototype.createFn=function(){
      var me=this,conditionResult;
      return function(){
        me.mock.fnCalled[me.fnName]=me.mock.fnCalled[me.fnName]||[];
        me.mock.fnCalled[me.fnName].push({
          arguments:arguments
        });
        if(me.conditionalReturn===MockBase.PARAM_CONDITION){
          conditionResult=me.returnParamConditional(arguments);
          if(conditionResult.pass){
            return conditionResult.ret;
          }
        }
        return me.retVal;
      };
    };
    
    return MockBase;
  }())
};

